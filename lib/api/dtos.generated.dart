// DTOs autogenerated at 2019-08-14 10:30:06

// ignore_for_file: avoid_unused_constructor_parameters,annotate_overrides,unnecessary_this

abstract class _Location {
  String get path;
}

mixin _LocationMixin on _Location {
  @override
  String toString() => '$runtimeType{path=$path}';
}

abstract class GetLocation<T> implements _Location {
  T bodyFromGetJson(dynamic json);
}

abstract class PostBodyLocation<T, U> implements _Location {
  U bodyFromPostJson(dynamic json);
}

abstract class PutBodyLocation<T, U> implements _Location {
  U bodyFromPutJson(dynamic json);
}

/// Fake class to represent more or less just void.
class Unit {
  Unit.fromJson(dynamic json);
}

class InstantWrapper {
  InstantWrapper.fromJson(dynamic json) : dateTime = DateTime.fromMillisecondsSinceEpoch(json as int, isUtc: true);
  DateTime dateTime;
  dynamic toJson() => dateTime.millisecondsSinceEpoch;
}

enum DescriptionSource { Wikipedia }
DescriptionSource convertDescriptionSourceFromJson(String value) {
  switch (value) {
    case 'Wikipedia':
      return DescriptionSource.Wikipedia;
  }
  throw StateError('illegal value $value for DescriptionSource');
}

String convertDescriptionSourceToJson(DescriptionSource value) {
  switch (value) {
    case DescriptionSource.Wikipedia:
      return 'Wikipedia';
  }
  throw StateError('illegal value $value');
}

enum DevicePlatform { iOS, Android, Unknown }
DevicePlatform convertDevicePlatformFromJson(String value) {
  switch (value) {
    case 'iOS':
      return DevicePlatform.iOS;
    case 'Android':
      return DevicePlatform.Android;
    case 'Unknown':
      return DevicePlatform.Unknown;
  }
  throw StateError('illegal value $value for DevicePlatform');
}

String convertDevicePlatformToJson(DevicePlatform value) {
  switch (value) {
    case DevicePlatform.iOS:
      return 'iOS';
    case DevicePlatform.Android:
      return 'Android';
    case DevicePlatform.Unknown:
      return 'Unknown';
  }
  throw StateError('illegal value $value');
}

enum FirebaseMessagingTopic { All, WeeklyChallenges }
FirebaseMessagingTopic convertFirebaseMessagingTopicFromJson(String value) {
  switch (value) {
    case 'All':
      return FirebaseMessagingTopic.All;
    case 'WeeklyChallenges':
      return FirebaseMessagingTopic.WeeklyChallenges;
  }
  throw StateError('illegal value $value for FirebaseMessagingTopic');
}

String convertFirebaseMessagingTopicToJson(FirebaseMessagingTopic value) {
  switch (value) {
    case FirebaseMessagingTopic.All:
      return 'All';
    case FirebaseMessagingTopic.WeeklyChallenges:
      return 'WeeklyChallenges';
  }
  throw StateError('illegal value $value');
}

enum GameChallengeAction { Start, Retrieve }
GameChallengeAction convertGameChallengeActionFromJson(String value) {
  switch (value) {
    case 'Start':
      return GameChallengeAction.Start;
    case 'Retrieve':
      return GameChallengeAction.Retrieve;
  }
  throw StateError('illegal value $value for GameChallengeAction');
}

String convertGameChallengeActionToJson(GameChallengeAction value) {
  switch (value) {
    case GameChallengeAction.Start:
      return 'Start';
    case GameChallengeAction.Retrieve:
      return 'Retrieve';
  }
  throw StateError('illegal value $value');
}

enum GameChallengeInviteType { LinkInvite, DirectInvite }
GameChallengeInviteType convertGameChallengeInviteTypeFromJson(String value) {
  switch (value) {
    case 'LinkInvite':
      return GameChallengeInviteType.LinkInvite;
    case 'DirectInvite':
      return GameChallengeInviteType.DirectInvite;
  }
  throw StateError('illegal value $value for GameChallengeInviteType');
}

String convertGameChallengeInviteTypeToJson(GameChallengeInviteType value) {
  switch (value) {
    case GameChallengeInviteType.LinkInvite:
      return 'LinkInvite';
    case GameChallengeInviteType.DirectInvite:
      return 'DirectInvite';
  }
  throw StateError('illegal value $value');
}

enum GameChallengeParticipantStatus { Invited, Ready, TurnsCreated, Finished }
GameChallengeParticipantStatus convertGameChallengeParticipantStatusFromJson(String value) {
  switch (value) {
    case 'Invited':
      return GameChallengeParticipantStatus.Invited;
    case 'Ready':
      return GameChallengeParticipantStatus.Ready;
    case 'TurnsCreated':
      return GameChallengeParticipantStatus.TurnsCreated;
    case 'Finished':
      return GameChallengeParticipantStatus.Finished;
  }
  throw StateError('illegal value $value for GameChallengeParticipantStatus');
}

String convertGameChallengeParticipantStatusToJson(GameChallengeParticipantStatus value) {
  switch (value) {
    case GameChallengeParticipantStatus.Invited:
      return 'Invited';
    case GameChallengeParticipantStatus.Ready:
      return 'Ready';
    case GameChallengeParticipantStatus.TurnsCreated:
      return 'TurnsCreated';
    case GameChallengeParticipantStatus.Finished:
      return 'Finished';
  }
  throw StateError('illegal value $value');
}

enum GameChallengeStatus { InvitationSent, Accepted, Finished }
GameChallengeStatus convertGameChallengeStatusFromJson(String value) {
  switch (value) {
    case 'InvitationSent':
      return GameChallengeStatus.InvitationSent;
    case 'Accepted':
      return GameChallengeStatus.Accepted;
    case 'Finished':
      return GameChallengeStatus.Finished;
  }
  throw StateError('illegal value $value for GameChallengeStatus');
}

String convertGameChallengeStatusToJson(GameChallengeStatus value) {
  switch (value) {
    case GameChallengeStatus.InvitationSent:
      return 'InvitationSent';
    case GameChallengeStatus.Accepted:
      return 'Accepted';
    case GameChallengeStatus.Finished:
      return 'Finished';
  }
  throw StateError('illegal value $value');
}

enum GameChallengeType { HeadsUpChallenge, OpenChallenge, WeeklyChallenge }
GameChallengeType convertGameChallengeTypeFromJson(String value) {
  switch (value) {
    case 'HeadsUpChallenge':
      return GameChallengeType.HeadsUpChallenge;
    case 'OpenChallenge':
      return GameChallengeType.OpenChallenge;
    case 'WeeklyChallenge':
      return GameChallengeType.WeeklyChallenge;
  }
  throw StateError('illegal value $value for GameChallengeType');
}

String convertGameChallengeTypeToJson(GameChallengeType value) {
  switch (value) {
    case GameChallengeType.HeadsUpChallenge:
      return 'HeadsUpChallenge';
    case GameChallengeType.OpenChallenge:
      return 'OpenChallenge';
    case GameChallengeType.WeeklyChallenge:
      return 'WeeklyChallenge';
  }
  throw StateError('illegal value $value');
}

enum GameNotificationType {
  ChallengeInvitationAccepted,
  ChallengeParticipantFinished,
  ChallengeInvitation,
  ChallengeWeekly
}
GameNotificationType convertGameNotificationTypeFromJson(String value) {
  switch (value) {
    case 'ChallengeInvitationAccepted':
      return GameNotificationType.ChallengeInvitationAccepted;
    case 'ChallengeParticipantFinished':
      return GameNotificationType.ChallengeParticipantFinished;
    case 'ChallengeInvitation':
      return GameNotificationType.ChallengeInvitation;
    case 'ChallengeWeekly':
      return GameNotificationType.ChallengeWeekly;
  }
  throw StateError('illegal value $value for GameNotificationType');
}

String convertGameNotificationTypeToJson(GameNotificationType value) {
  switch (value) {
    case GameNotificationType.ChallengeInvitationAccepted:
      return 'ChallengeInvitationAccepted';
    case GameNotificationType.ChallengeParticipantFinished:
      return 'ChallengeParticipantFinished';
    case GameNotificationType.ChallengeInvitation:
      return 'ChallengeInvitation';
    case GameNotificationType.ChallengeWeekly:
      return 'ChallengeWeekly';
  }
  throw StateError('illegal value $value');
}

enum GameUserType { User, Admin, Tester, AutoChallengeCreator }
GameUserType convertGameUserTypeFromJson(String value) {
  switch (value) {
    case 'User':
      return GameUserType.User;
    case 'Admin':
      return GameUserType.Admin;
    case 'Tester':
      return GameUserType.Tester;
    case 'AutoChallengeCreator':
      return GameUserType.AutoChallengeCreator;
  }
  throw StateError('illegal value $value for GameUserType');
}

String convertGameUserTypeToJson(GameUserType value) {
  switch (value) {
    case GameUserType.User:
      return 'User';
    case GameUserType.Admin:
      return 'Admin';
    case GameUserType.Tester:
      return 'Tester';
    case GameUserType.AutoChallengeCreator:
      return 'AutoChallengeCreator';
  }
  throw StateError('illegal value $value');
}

enum ImageType { FAVICON, LOGO, LOGO_GUESSED, UNKNOWN, USER_AVATAR }
ImageType convertImageTypeFromJson(String value) {
  switch (value) {
    case 'FAVICON':
      return ImageType.FAVICON;
    case 'LOGO':
      return ImageType.LOGO;
    case 'LOGO_GUESSED':
      return ImageType.LOGO_GUESSED;
    case 'UNKNOWN':
      return ImageType.UNKNOWN;
    case 'USER_AVATAR':
      return ImageType.USER_AVATAR;
  }
  throw StateError('illegal value $value for ImageType');
}

String convertImageTypeToJson(ImageType value) {
  switch (value) {
    case ImageType.FAVICON:
      return 'FAVICON';
    case ImageType.LOGO:
      return 'LOGO';
    case ImageType.LOGO_GUESSED:
      return 'LOGO_GUESSED';
    case ImageType.UNKNOWN:
      return 'UNKNOWN';
    case ImageType.USER_AVATAR:
      return 'USER_AVATAR';
  }
  throw StateError('illegal value $value');
}

enum ImportType { DEGIRO, HELLO_BANK, YAHOO, MANUAL, CUSTOM_CSV_FORMAT, UNKNOWN }
ImportType convertImportTypeFromJson(String value) {
  switch (value) {
    case 'DEGIRO':
      return ImportType.DEGIRO;
    case 'HELLO_BANK':
      return ImportType.HELLO_BANK;
    case 'YAHOO':
      return ImportType.YAHOO;
    case 'MANUAL':
      return ImportType.MANUAL;
    case 'CUSTOM_CSV_FORMAT':
      return ImportType.CUSTOM_CSV_FORMAT;
    case 'UNKNOWN':
      return ImportType.UNKNOWN;
  }
  throw StateError('illegal value $value for ImportType');
}

String convertImportTypeToJson(ImportType value) {
  switch (value) {
    case ImportType.DEGIRO:
      return 'DEGIRO';
    case ImportType.HELLO_BANK:
      return 'HELLO_BANK';
    case ImportType.YAHOO:
      return 'YAHOO';
    case ImportType.MANUAL:
      return 'MANUAL';
    case ImportType.CUSTOM_CSV_FORMAT:
      return 'CUSTOM_CSV_FORMAT';
    case ImportType.UNKNOWN:
      return 'UNKNOWN';
  }
  throw StateError('illegal value $value');
}

enum InstrumentType { ETP_MUTUAL_FUND, STOCK, STOCK_GUESSED, ADR, CURRENCY, CRYPTO_CURRENCY, INDEX, FUTURE }
InstrumentType convertInstrumentTypeFromJson(String value) {
  switch (value) {
    case 'ETP_MUTUAL_FUND':
      return InstrumentType.ETP_MUTUAL_FUND;
    case 'STOCK':
      return InstrumentType.STOCK;
    case 'STOCK_GUESSED':
      return InstrumentType.STOCK_GUESSED;
    case 'ADR':
      return InstrumentType.ADR;
    case 'CURRENCY':
      return InstrumentType.CURRENCY;
    case 'CRYPTO_CURRENCY':
      return InstrumentType.CRYPTO_CURRENCY;
    case 'INDEX':
      return InstrumentType.INDEX;
    case 'FUTURE':
      return InstrumentType.FUTURE;
  }
  throw StateError('illegal value $value for InstrumentType');
}

String convertInstrumentTypeToJson(InstrumentType value) {
  switch (value) {
    case InstrumentType.ETP_MUTUAL_FUND:
      return 'ETP_MUTUAL_FUND';
    case InstrumentType.STOCK:
      return 'STOCK';
    case InstrumentType.STOCK_GUESSED:
      return 'STOCK_GUESSED';
    case InstrumentType.ADR:
      return 'ADR';
    case InstrumentType.CURRENCY:
      return 'CURRENCY';
    case InstrumentType.CRYPTO_CURRENCY:
      return 'CRYPTO_CURRENCY';
    case InstrumentType.INDEX:
      return 'INDEX';
    case InstrumentType.FUTURE:
      return 'FUTURE';
  }
  throw StateError('illegal value $value');
}

enum LabelPrivacy { PRIVATE, URL_TOKEN_ACCESS }
LabelPrivacy convertLabelPrivacyFromJson(String value) {
  switch (value) {
    case 'PRIVATE':
      return LabelPrivacy.PRIVATE;
    case 'URL_TOKEN_ACCESS':
      return LabelPrivacy.URL_TOKEN_ACCESS;
  }
  throw StateError('illegal value $value for LabelPrivacy');
}

String convertLabelPrivacyToJson(LabelPrivacy value) {
  switch (value) {
    case LabelPrivacy.PRIVATE:
      return 'PRIVATE';
    case LabelPrivacy.URL_TOKEN_ACCESS:
      return 'URL_TOKEN_ACCESS';
  }
  throw StateError('illegal value $value');
}

enum LabelType { PORTFOLIO }
LabelType convertLabelTypeFromJson(String value) {
  switch (value) {
    case 'PORTFOLIO':
      return LabelType.PORTFOLIO;
  }
  throw StateError('illegal value $value for LabelType');
}

String convertLabelTypeToJson(LabelType value) {
  switch (value) {
    case LabelType.PORTFOLIO:
      return 'PORTFOLIO';
  }
  throw StateError('illegal value $value');
}

enum MoverType { Up, Down }
MoverType convertMoverTypeFromJson(String value) {
  switch (value) {
    case 'Up':
      return MoverType.Up;
    case 'Down':
      return MoverType.Down;
  }
  throw StateError('illegal value $value for MoverType');
}

String convertMoverTypeToJson(MoverType value) {
  switch (value) {
    case MoverType.Up:
      return 'Up';
    case MoverType.Down:
      return 'Down';
  }
  throw StateError('illegal value $value');
}

enum PdInstrumentType { STOCK, CURRENCY, CRYPTO_CURRENCY, ETF, INDEX, FUTURE, UNKNOWN }
PdInstrumentType convertPdInstrumentTypeFromJson(String value) {
  switch (value) {
    case 'STOCK':
      return PdInstrumentType.STOCK;
    case 'CURRENCY':
      return PdInstrumentType.CURRENCY;
    case 'CRYPTO_CURRENCY':
      return PdInstrumentType.CRYPTO_CURRENCY;
    case 'ETF':
      return PdInstrumentType.ETF;
    case 'INDEX':
      return PdInstrumentType.INDEX;
    case 'FUTURE':
      return PdInstrumentType.FUTURE;
    case 'UNKNOWN':
      return PdInstrumentType.UNKNOWN;
  }
  throw StateError('illegal value $value for PdInstrumentType');
}

String convertPdInstrumentTypeToJson(PdInstrumentType value) {
  switch (value) {
    case PdInstrumentType.STOCK:
      return 'STOCK';
    case PdInstrumentType.CURRENCY:
      return 'CURRENCY';
    case PdInstrumentType.CRYPTO_CURRENCY:
      return 'CRYPTO_CURRENCY';
    case PdInstrumentType.ETF:
      return 'ETF';
    case PdInstrumentType.INDEX:
      return 'INDEX';
    case PdInstrumentType.FUTURE:
      return 'FUTURE';
    case PdInstrumentType.UNKNOWN:
      return 'UNKNOWN';
  }
  throw StateError('illegal value $value');
}

enum PermissionType { OWNER, VIEWER }
PermissionType convertPermissionTypeFromJson(String value) {
  switch (value) {
    case 'OWNER':
      return PermissionType.OWNER;
    case 'VIEWER':
      return PermissionType.VIEWER;
  }
  throw StateError('illegal value $value for PermissionType');
}

String convertPermissionTypeToJson(PermissionType value) {
  switch (value) {
    case PermissionType.OWNER:
      return 'OWNER';
    case PermissionType.VIEWER:
      return 'VIEWER';
  }
  throw StateError('illegal value $value');
}

enum StatsType { Low52Weeks, High52Weeks }
StatsType convertStatsTypeFromJson(String value) {
  switch (value) {
    case 'Low52Weeks':
      return StatsType.Low52Weeks;
    case 'High52Weeks':
      return StatsType.High52Weeks;
  }
  throw StateError('illegal value $value for StatsType');
}

String convertStatsTypeToJson(StatsType value) {
  switch (value) {
    case StatsType.Low52Weeks:
      return 'Low52Weeks';
    case StatsType.High52Weeks:
      return 'High52Weeks';
  }
  throw StateError('illegal value $value');
}

enum TransactionType { BUY, SELL }
TransactionType convertTransactionTypeFromJson(String value) {
  switch (value) {
    case 'BUY':
      return TransactionType.BUY;
    case 'SELL':
      return TransactionType.SELL;
  }
  throw StateError('illegal value $value for TransactionType');
}

String convertTransactionTypeToJson(TransactionType value) {
  switch (value) {
    case TransactionType.BUY:
      return 'BUY';
    case TransactionType.SELL:
      return 'SELL';
  }
  throw StateError('illegal value $value');
}

enum TransactionValueType {
  INSTRUMENT_PRICE,
  FEE_TRANSACTION,
  FEE_FOREIGN,
  TOTAL_VALUE,
  CURRENCY_CONVERSION_RATE,
  DIVIDEND
}
TransactionValueType convertTransactionValueTypeFromJson(String value) {
  switch (value) {
    case 'INSTRUMENT_PRICE':
      return TransactionValueType.INSTRUMENT_PRICE;
    case 'FEE_TRANSACTION':
      return TransactionValueType.FEE_TRANSACTION;
    case 'FEE_FOREIGN':
      return TransactionValueType.FEE_FOREIGN;
    case 'TOTAL_VALUE':
      return TransactionValueType.TOTAL_VALUE;
    case 'CURRENCY_CONVERSION_RATE':
      return TransactionValueType.CURRENCY_CONVERSION_RATE;
    case 'DIVIDEND':
      return TransactionValueType.DIVIDEND;
  }
  throw StateError('illegal value $value for TransactionValueType');
}

String convertTransactionValueTypeToJson(TransactionValueType value) {
  switch (value) {
    case TransactionValueType.INSTRUMENT_PRICE:
      return 'INSTRUMENT_PRICE';
    case TransactionValueType.FEE_TRANSACTION:
      return 'FEE_TRANSACTION';
    case TransactionValueType.FEE_FOREIGN:
      return 'FEE_FOREIGN';
    case TransactionValueType.TOTAL_VALUE:
      return 'TOTAL_VALUE';
    case TransactionValueType.CURRENCY_CONVERSION_RATE:
      return 'CURRENCY_CONVERSION_RATE';
    case TransactionValueType.DIVIDEND:
      return 'DIVIDEND';
  }
  throw StateError('illegal value $value');
}

enum UserType { UNKNOWN, UNKNOWN_FASTSPRING, FREE, PREMIUM, ADMIN, FRIENDLIES }
UserType convertUserTypeFromJson(String value) {
  switch (value) {
    case 'UNKNOWN':
      return UserType.UNKNOWN;
    case 'UNKNOWN_FASTSPRING':
      return UserType.UNKNOWN_FASTSPRING;
    case 'FREE':
      return UserType.FREE;
    case 'PREMIUM':
      return UserType.PREMIUM;
    case 'ADMIN':
      return UserType.ADMIN;
    case 'FRIENDLIES':
      return UserType.FRIENDLIES;
  }
  throw StateError('illegal value $value for UserType');
}

String convertUserTypeToJson(UserType value) {
  switch (value) {
    case UserType.UNKNOWN:
      return 'UNKNOWN';
    case UserType.UNKNOWN_FASTSPRING:
      return 'UNKNOWN_FASTSPRING';
    case UserType.FREE:
      return 'FREE';
    case UserType.PREMIUM:
      return 'PREMIUM';
    case UserType.ADMIN:
      return 'ADMIN';
    case UserType.FRIENDLIES:
      return 'FRIENDLIES';
  }
  throw StateError('illegal value $value');
}

class AppMetricsDto {
  AppMetricsDto(this.labelCount, this.lastImportEodStats, this.logEventCount, this.userCount);
  AppMetricsDto.fromJson(Map<String, dynamic> json)
      : labelCount = json['labelCount'] as int,
        lastImportEodStats = json['lastImportEodStats'] as dynamic,
        logEventCount = json['logEventCount'] as int,
        userCount = json['userCount'] as int;

  Map<String, dynamic> toJson() => <String, dynamic>{
        'labelCount': labelCount,
        'lastImportEodStats': lastImportEodStats,
        'logEventCount': logEventCount,
        'userCount': userCount,
      };

  int labelCount;
  dynamic lastImportEodStats;
  int logEventCount;
  int userCount;
}

class AuthenticatedTestMethodLocation extends _Location
    with _LocationMixin
    implements
        GetLocation<TestMethodGetResponse>,
        PostBodyLocation<TestMethodPostRequest, TestMethodPostResponse>,
        PutBodyLocation<TestMethodPutRequest, TestMethodPutResponse> {
  AuthenticatedTestMethodLocation(this.authParam);
  AuthenticatedTestMethodLocation.fromJson(Map<String, dynamic> json) : authParam = json['authParam'] as String;

  Map<String, dynamic> toJson() => <String, dynamic>{
        'authParam': authParam,
      };

  @override
  String get path => 'api/test/auth/method/{authParam}'.replaceAll('{authParam}', this.authParam);

  String authParam;
  @override
  TestMethodGetResponse bodyFromGetJson(dynamic json) => TestMethodGetResponse.fromJson(json as Map<String, dynamic>);
  @override
  TestMethodPostResponse bodyFromPostJson(dynamic json) =>
      TestMethodPostResponse.fromJson(json as Map<String, dynamic>);
  @override
  TestMethodPutResponse bodyFromPutJson(dynamic json) => TestMethodPutResponse.fromJson(json as Map<String, dynamic>);
}

class BiggestMover {
  BiggestMover(this.compareValue, this.instrument, this.value);
  BiggestMover.fromJson(Map<String, dynamic> json)
      : compareValue = (json['compareValue'] as num).toDouble(),
        instrument = PdInstrumentDto.fromJson(json['instrument'] as Map<String, dynamic>),
        value = (json['value'] as num).toDouble();

  Map<String, dynamic> toJson() => <String, dynamic>{
        'compareValue': compareValue,
        'instrument': instrument.toJson(),
        'value': value,
      };

  double compareValue;
  PdInstrumentDto instrument;
  double value;
}

class BiggestMovers extends _Location with _LocationMixin implements GetLocation<BiggestMoversResponse> {
  BiggestMovers(this.endDate, this.startDate, this.type);
  BiggestMovers.fromJson(Map<String, dynamic> json)
      : endDate = json['endDate'] as /* yyyy-mm-dd date LocalDate */ String,
        startDate = json['startDate'] as /* yyyy-mm-dd date LocalDate */ String,
        type = convertMoverTypeFromJson(json['type'] as String);

  Map<String, dynamic> toJson() => <String, dynamic>{
        'endDate': endDate,
        'startDate': startDate,
        'type': convertMoverTypeToJson(type),
      };

  @override
  String get path => Uri.parse('api/pricedata/biggestMovers').replace(queryParameters: <String, dynamic>{
        'endDate': endDate?.toString(),
        'startDate': startDate?.toString(),
        'type': type,
      }).toString();

  /* yyyy-mm-dd date LocalDate */ String endDate;
  /* yyyy-mm-dd date LocalDate */ String startDate;
  MoverType type;
  @override
  BiggestMoversResponse bodyFromGetJson(dynamic json) => BiggestMoversResponse.fromJson(json as Map<String, dynamic>);
}

class BiggestMoversResponse {
  BiggestMoversResponse(this.biggestMovers);
  BiggestMoversResponse.fromJson(Map<String, dynamic> json)
      : biggestMovers = (json['biggestMovers'] as List<dynamic>)
            .map((dynamic val) => BiggestMover.fromJson(val as Map<String, dynamic>))
            .toList();

  Map<String, dynamic> toJson() => <String, dynamic>{
        'biggestMovers': biggestMovers.map<dynamic>((dynamic val) => val.toJson()).toList(),
      };

  List<BiggestMover> biggestMovers;
}

class CompanyInfoDescription {
  CompanyInfoDescription(this.content, this.source, /* nullable */ this.sourceUrl);
  CompanyInfoDescription.fromJson(Map<String, dynamic> json)
      : content = json['content'] as String,
        source = convertDescriptionSourceFromJson(json['source'] as String),
        sourceUrl = json['sourceUrl'] as String;

  Map<String, dynamic> toJson() => <String, dynamic>{
        'content': content,
        'source': convertDescriptionSourceToJson(source),
        'sourceUrl': sourceUrl,
      };

  String content;
  DescriptionSource source;
  String sourceUrl;
}

class CompanyInfoDetails {
  CompanyInfoDetails(this.description, /* nullable */ this.extractText, this.instrumentKey, this.name, this.symbol,
      this.website, /* nullable */ this.wikipediaArticleUri);
  CompanyInfoDetails.fromJson(Map<String, dynamic> json)
      : description = json['description'] as String,
        extractText = json['extractText'] == null
            ? null
            : CompanyInfoDescription.fromJson(json['extractText'] as Map<String, dynamic>),
        instrumentKey = json['instrumentKey'] as String,
        name = json['name'] as String,
        symbol = json['symbol'] as String,
        website = json['website'] as String,
        wikipediaArticleUri = json['wikipediaArticleUri'] as String;

  Map<String, dynamic> toJson() => <String, dynamic>{
        'description': description,
        'extractText': extractText?.toJson(),
        'instrumentKey': instrumentKey,
        'name': name,
        'symbol': symbol,
        'website': website,
        'wikipediaArticleUri': wikipediaArticleUri,
      };

  String description;
  CompanyInfoDescription extractText;
  String instrumentKey;
  String name;
  String symbol;
  String website;
  String wikipediaArticleUri;
}

class ContextAnonymousDto implements ContextDto {
  ContextAnonymousDto(this.loggedIn);
  ContextAnonymousDto.fromJson(Map<String, dynamic> json) : loggedIn = json['loggedIn'] as bool;

  Map<String, dynamic> toJson() => <String, dynamic>{
        'loggedIn': loggedIn,
      };

  bool loggedIn;
}

class ContextDto {
  ContextDto(this.loggedIn);
  ContextDto.fromJson(Map<String, dynamic> json) : loggedIn = json['loggedIn'] as bool;

  Map<String, dynamic> toJson() => <String, dynamic>{
        'loggedIn': loggedIn,
      };

  bool loggedIn;
}

class ContextLoggedInDto implements ContextDto {
  ContextLoggedInDto(this.loggedIn, this.email, this.userId, this.userType);
  ContextLoggedInDto.fromJson(Map<String, dynamic> json)
      : loggedIn = json['loggedIn'] as bool,
        email = json['email'] as String,
        userId = json['userId'] as String,
        userType = convertUserTypeFromJson(json['userType'] as String);

  Map<String, dynamic> toJson() => <String, dynamic>{
        'loggedIn': loggedIn,
        'email': email,
        'userId': userId,
        'userType': convertUserTypeToJson(userType),
      };

  bool loggedIn;
  String email;
  String userId;
  UserType userType;
}

class ContextRequest extends _Location with _LocationMixin implements PostBodyLocation<EmptyRequestDto, ContextDto> {
  ContextRequest();
  ContextRequest.fromJson(Map<String, dynamic> json) : super();

  Map<String, dynamic> toJson() => <String, dynamic>{};

  @override
  String get path => 'api/auth/context';

  @override
  ContextDto bodyFromPostJson(dynamic json) => ContextDto.fromJson(json as Map<String, dynamic>);
}

class Currency {
  Currency(this.currencyCode, this.defaultFractionDigits, this.numericCode);
  Currency.fromJson(Map<String, dynamic> json)
      : currencyCode = json['currencyCode'] as String,
        defaultFractionDigits = json['defaultFractionDigits'] as int,
        numericCode = json['numericCode'] as int;

  Map<String, dynamic> toJson() => <String, dynamic>{
        'currencyCode': currencyCode,
        'defaultFractionDigits': defaultFractionDigits,
        'numericCode': numericCode,
      };

  String currencyCode;
  int defaultFractionDigits;
  int numericCode;
}

class CurrencyConversion {
  CurrencyConversion(this.source, this.symbol, this.target);
  CurrencyConversion.fromJson(Map<String, dynamic> json)
      : source = json['source'] as String,
        symbol = json['symbol'] as String,
        target = json['target'] as String;

  Map<String, dynamic> toJson() => <String, dynamic>{
        'source': source,
        'symbol': symbol,
        'target': target,
      };

  String source;
  String symbol;
  String target;
}

class CurrencyInfo {
  CurrencyInfo(this.code, this.name, this.symbol);
  CurrencyInfo.fromJson(Map<String, dynamic> json)
      : code = json['code'] as String,
        name = json['name'] as String,
        symbol = json['symbol'] as String;

  Map<String, dynamic> toJson() => <String, dynamic>{
        'code': code,
        'name': name,
        'symbol': symbol,
      };

  String code;
  String name;
  String symbol;
}

class CustomCsvParserConfig implements ParserConfig {
  CustomCsvParserConfig(
      this.countColumn,
      this.csvDelimiter,
      this.defaultCurrency,
      this.exchangeColumn,
      this.exchangeMicMapping,
      this.priceColumn,
      this.priceCurrencyColumn,
      this.tickerSymbolColumn,
      this.transactionDateColumn,
      this.transactionTypeColumn);
  CustomCsvParserConfig.fromJson(Map<String, dynamic> json)
      : countColumn = json['countColumn'] as int,
        csvDelimiter = json['csvDelimiter'] as String,
        defaultCurrency = json['defaultCurrency'] as String,
        exchangeColumn = json['exchangeColumn'] as int,
        exchangeMicMapping = (json['exchangeMicMapping'] as Map<dynamic, dynamic>).map<String, String>(
            (dynamic key, dynamic value) => MapEntry<String, String>(key as String, value as String)),
        priceColumn = json['priceColumn'] as int,
        priceCurrencyColumn = json['priceCurrencyColumn'] as int,
        tickerSymbolColumn = json['tickerSymbolColumn'] as int,
        transactionDateColumn = json['transactionDateColumn'] as int,
        transactionTypeColumn = json['transactionTypeColumn'] as int;

  Map<String, dynamic> toJson() => <String, dynamic>{
        'countColumn': countColumn,
        'csvDelimiter': csvDelimiter,
        'defaultCurrency': defaultCurrency,
        'exchangeColumn': exchangeColumn,
        'exchangeMicMapping': exchangeMicMapping
            .map<String, dynamic>((dynamic key, dynamic value) => MapEntry<String, dynamic>((key) as String, (value))),
        'priceColumn': priceColumn,
        'priceCurrencyColumn': priceCurrencyColumn,
        'tickerSymbolColumn': tickerSymbolColumn,
        'transactionDateColumn': transactionDateColumn,
        'transactionTypeColumn': transactionTypeColumn,
      };

  int countColumn;
  String csvDelimiter;
  String defaultCurrency;
  int exchangeColumn;
  Map<String, String> exchangeMicMapping;
  int priceColumn;
  int priceCurrencyColumn;
  int tickerSymbolColumn;
  int transactionDateColumn;
  int transactionTypeColumn;
}

class EmptyRequestDto {
  EmptyRequestDto();
  EmptyRequestDto.fromJson(Map<String, dynamic> json) : super();

  Map<String, dynamic> toJson() => <String, dynamic>{};
}

class EodInfo {
  EodInfo(this.fd);
  EodInfo.fromJson(Map<String, dynamic> json) : fd = json['fd'] as /* yyyy-mm-dd date LocalDate */ String;

  Map<String, dynamic> toJson() => <String, dynamic>{
        'fd': fd,
      };

  /* yyyy-mm-dd date LocalDate */ String fd;
}

class EodStockData extends _Location with _LocationMixin implements GetLocation<EodStockDataResponse> {
  EodStockData(/* nullable */ this.currency, this.end, /* nullable */ this.sampleEveryN, this.start, this.symbols);
  EodStockData.fromJson(Map<String, dynamic> json)
      : currency = json['currency'] as String,
        end = json['end'] as /* yyyy-mm-dd date LocalDate */ String,
        sampleEveryN = json['sampleEveryN'] as int,
        start = json['start'] as /* yyyy-mm-dd date LocalDate */ String,
        symbols = (json['symbols'] as List<dynamic>).map((dynamic val) => val as String).toList();

  Map<String, dynamic> toJson() => <String, dynamic>{
        'currency': currency,
        'end': end,
        'sampleEveryN': sampleEveryN,
        'start': start,
        'symbols': symbols.map<dynamic>((dynamic val) => val).toList(),
      };

  @override
  String get path => Uri.parse('api/pricedata/eod').replace(queryParameters: <String, dynamic>{
        if (currency != null) 'currency': currency?.toString(),
        'end': end?.toString(),
        if (sampleEveryN != null) 'sampleEveryN': sampleEveryN?.toString(),
        'start': start?.toString(),
        'symbols': symbols,
      }).toString();

  String currency;
  /* yyyy-mm-dd date LocalDate */ String end;
  int sampleEveryN;
  /* yyyy-mm-dd date LocalDate */ String start;
  List<String> symbols;
  @override
  EodStockDataResponse bodyFromGetJson(dynamic json) => EodStockDataResponse.fromJson(json as Map<String, dynamic>);
}

class EodStockDataResponse {
  EodStockDataResponse(this.currencyConversions, this.data, this.info, this.sampleEveryNth, this.snapshot);
  EodStockDataResponse.fromJson(Map<String, dynamic> json)
      : currencyConversions = (json['currencyConversions'] as List<dynamic>)
            .map((dynamic val) => CurrencyConversion.fromJson(val as Map<String, dynamic>))
            .toList(),
        data = (json['data'] as Map<dynamic, dynamic>).map<String, List<double>>((dynamic key, dynamic value) =>
            MapEntry<String, List<double>>(
                key as String, (value as List<dynamic>).map((dynamic val) => (val as num).toDouble()).toList())),
        info = (json['info'] as Map<dynamic, dynamic>).map<String, EodInfo>((dynamic key, dynamic value) =>
            MapEntry<String, EodInfo>(key as String, EodInfo.fromJson(value as Map<String, dynamic>))),
        sampleEveryNth = json['sampleEveryNth'] as int,
        snapshot = (json['snapshot'] as Map<dynamic, dynamic>).map<String, PdInstrument>((dynamic key, dynamic value) =>
            MapEntry<String, PdInstrument>(key as String, PdInstrument.fromJson(value as Map<String, dynamic>)));

  Map<String, dynamic> toJson() => <String, dynamic>{
        'currencyConversions': currencyConversions.map<dynamic>((dynamic val) => val.toJson()).toList(),
        'data': data.map<String, dynamic>((dynamic key, dynamic value) =>
            MapEntry<String, dynamic>((key) as String, (value.map<dynamic>((dynamic val) => val).toList()))),
        'info': info.map<String, dynamic>(
            (dynamic key, dynamic value) => MapEntry<String, dynamic>((key) as String, (value.toJson()))),
        'sampleEveryNth': sampleEveryNth,
        'snapshot': snapshot.map<String, dynamic>(
            (dynamic key, dynamic value) => MapEntry<String, dynamic>((key) as String, (value.toJson()))),
      };

  List<CurrencyConversion> currencyConversions;
  Map<String, List<double>> data;
  Map<String, EodInfo> info;
  int sampleEveryNth;
  Map<String, PdInstrument> snapshot;
}

class ErrorResponse {
  ErrorResponse(this.message);
  ErrorResponse.fromJson(Map<String, dynamic> json) : message = json['message'] as String;

  Map<String, dynamic> toJson() => <String, dynamic>{
        'message': message,
      };

  String message;
}

class Exchange {
  Exchange(this.country, this.equityExchangeName, this.id, this.label, this.micCode, this.name, this.operatingMicCode);
  Exchange.fromJson(Map<String, dynamic> json)
      : country = json['country'] as String,
        equityExchangeName = json['equityExchangeName'] as String,
        id = json['id'] as String,
        label = json['label'] as String,
        micCode = json['micCode'] as String,
        name = json['name'] as String,
        operatingMicCode = json['operatingMicCode'] as String;

  Map<String, dynamic> toJson() => <String, dynamic>{
        'country': country,
        'equityExchangeName': equityExchangeName,
        'id': id,
        'label': label,
        'micCode': micCode,
        'name': name,
        'operatingMicCode': operatingMicCode,
      };

  String country;
  String equityExchangeName;
  String id;
  String label;
  String micCode;
  String name;
  String operatingMicCode;
}

class GameChallengeDetailsParticipants {
  GameChallengeDetailsParticipants(this.baseInfo, this.myself, this.statsCorrectAnswers, this.status);
  GameChallengeDetailsParticipants.fromJson(Map<String, dynamic> json)
      : baseInfo = GameUserBaseInfo.fromJson(json['baseInfo'] as Map<String, dynamic>),
        myself = json['myself'] as bool,
        statsCorrectAnswers = json['statsCorrectAnswers'] as int,
        status = convertGameChallengeParticipantStatusFromJson(json['status'] as String);

  Map<String, dynamic> toJson() => <String, dynamic>{
        'baseInfo': baseInfo.toJson(),
        'myself': myself,
        'statsCorrectAnswers': statsCorrectAnswers,
        'status': convertGameChallengeParticipantStatusToJson(status),
      };

  GameUserBaseInfo baseInfo;
  bool myself;
  int statsCorrectAnswers;
  GameChallengeParticipantStatus status;
}

class GameChallengeDetailsResponse {
  GameChallengeDetailsResponse(this.baseInfo, this.participants);
  GameChallengeDetailsResponse.fromJson(Map<String, dynamic> json)
      : baseInfo = GameChallengeInfoDto.fromJson(json['baseInfo'] as Map<String, dynamic>),
        participants = (json['participants'] as List<dynamic>)
            .map((dynamic val) => GameChallengeDetailsParticipants.fromJson(val as Map<String, dynamic>))
            .toList();

  Map<String, dynamic> toJson() => <String, dynamic>{
        'baseInfo': baseInfo.toJson(),
        'participants': participants.map<dynamic>((dynamic val) => val.toJson()).toList(),
      };

  GameChallengeInfoDto baseInfo;
  List<GameChallengeDetailsParticipants> participants;
}

class GameChallengeDto {
  GameChallengeDto(this.challengeId, this.simpleGame);
  GameChallengeDto.fromJson(Map<String, dynamic> json)
      : challengeId = json['challengeId'] as String,
        simpleGame = (json['simpleGame'] as List<dynamic>)
            .map((dynamic val) => GameSimpleSetResponse.fromJson(val as Map<String, dynamic>))
            .toList();

  Map<String, dynamic> toJson() => <String, dynamic>{
        'challengeId': challengeId,
        'simpleGame': simpleGame.map<dynamic>((dynamic val) => val.toJson()).toList(),
      };

  String challengeId;
  List<GameSimpleSetResponse> simpleGame;
}

class GameChallengeInfoDto {
  GameChallengeInfoDto(this.challengeId, this.createdAt, /* nullable */ this.createdBy, /* nullable */ this.inviteToken,
      this.myParticipantStatus, this.status, this.title, this.type);
  GameChallengeInfoDto.fromJson(Map<String, dynamic> json)
      : challengeId = json['challengeId'] as String,
        createdAt = InstantWrapper.fromJson(json['createdAt'] as int),
        createdBy =
            json['createdBy'] == null ? null : GameUserBaseInfo.fromJson(json['createdBy'] as Map<String, dynamic>),
        inviteToken = json['inviteToken'] as String,
        myParticipantStatus = convertGameChallengeParticipantStatusFromJson(json['myParticipantStatus'] as String),
        status = convertGameChallengeStatusFromJson(json['status'] as String),
        title = json['title'] as String,
        type = convertGameChallengeTypeFromJson(json['type'] as String);

  Map<String, dynamic> toJson() => <String, dynamic>{
        'challengeId': challengeId,
        'createdAt': createdAt.toJson(),
        'createdBy': createdBy?.toJson(),
        'inviteToken': inviteToken,
        'myParticipantStatus': convertGameChallengeParticipantStatusToJson(myParticipantStatus),
        'status': convertGameChallengeStatusToJson(status),
        'title': title,
        'type': convertGameChallengeTypeToJson(type),
      };

  String challengeId;
  InstantWrapper createdAt;
  GameUserBaseInfo createdBy;
  String inviteToken;
  GameChallengeParticipantStatus myParticipantStatus;
  GameChallengeStatus status;
  String title;
  GameChallengeType type;
}

class GameChallengeInviteCreateRequest {
  GameChallengeInviteCreateRequest(this.displayName, this.gameUserToken, this.type);
  GameChallengeInviteCreateRequest.fromJson(Map<String, dynamic> json)
      : displayName = json['displayName'] as String,
        gameUserToken = json['gameUserToken'] as String,
        type = convertGameChallengeInviteTypeFromJson(json['type'] as String);

  Map<String, dynamic> toJson() => <String, dynamic>{
        'displayName': displayName,
        'gameUserToken': gameUserToken,
        'type': convertGameChallengeInviteTypeToJson(type),
      };

  String displayName;
  String gameUserToken;
  GameChallengeInviteType type;
}

class GameChallengeInviteInfoAcceptRequest {
  GameChallengeInviteInfoAcceptRequest();
  GameChallengeInviteInfoAcceptRequest.fromJson(Map<String, dynamic> json) : super();

  Map<String, dynamic> toJson() => <String, dynamic>{};
}

class GameChallengeInviteInfoLocation extends _Location
    with _LocationMixin
    implements
        GetLocation<GameChallengeInviteInfoResponse>,
        PutBodyLocation<GameChallengeInviteInfoAcceptRequest, GameChallengeDto> {
  GameChallengeInviteInfoLocation(this.token);
  GameChallengeInviteInfoLocation.fromJson(Map<String, dynamic> json) : token = json['token'] as String;

  Map<String, dynamic> toJson() => <String, dynamic>{
        'token': token,
      };

  @override
  String get path => 'api/game/challenge/invite/{token}'.replaceAll('{token}', this.token);

  String token;
  @override
  GameChallengeInviteInfoResponse bodyFromGetJson(dynamic json) =>
      GameChallengeInviteInfoResponse.fromJson(json as Map<String, dynamic>);
  @override
  GameChallengeDto bodyFromPutJson(dynamic json) => GameChallengeDto.fromJson(json as Map<String, dynamic>);
}

class GameChallengeInviteInfoResponse {
  GameChallengeInviteInfoResponse(this.challengeType, this.createdBy);
  GameChallengeInviteInfoResponse.fromJson(Map<String, dynamic> json)
      : challengeType = convertGameChallengeTypeFromJson(json['challengeType'] as String),
        createdBy = GameUserBaseInfo.fromJson(json['createdBy'] as Map<String, dynamic>);

  Map<String, dynamic> toJson() => <String, dynamic>{
        'challengeType': convertGameChallengeTypeToJson(challengeType),
        'createdBy': createdBy.toJson(),
      };

  GameChallengeType challengeType;
  GameUserBaseInfo createdBy;
}

class GameChallengeInviteLocation extends _Location
    with _LocationMixin
    implements PostBodyLocation<GameChallengeInviteCreateRequest, GameChallengeInviteResponse> {
  GameChallengeInviteLocation();
  GameChallengeInviteLocation.fromJson(Map<String, dynamic> json) : super();

  Map<String, dynamic> toJson() => <String, dynamic>{};

  @override
  String get path => 'api/game/challenge/invite';

  @override
  GameChallengeInviteResponse bodyFromPostJson(dynamic json) =>
      GameChallengeInviteResponse.fromJson(json as Map<String, dynamic>);
}

class GameChallengeInviteResponse {
  GameChallengeInviteResponse(this.inviteToken);
  GameChallengeInviteResponse.fromJson(Map<String, dynamic> json) : inviteToken = json['inviteToken'] as String;

  Map<String, dynamic> toJson() => <String, dynamic>{
        'inviteToken': inviteToken,
      };

  String inviteToken;
}

class GameChallengeListLocation extends _Location
    with _LocationMixin
    implements GetLocation<GameChallengeListResponse> {
  GameChallengeListLocation();
  GameChallengeListLocation.fromJson(Map<String, dynamic> json) : super();

  Map<String, dynamic> toJson() => <String, dynamic>{};

  @override
  String get path => 'api/game/challenge/list';

  @override
  GameChallengeListResponse bodyFromGetJson(dynamic json) =>
      GameChallengeListResponse.fromJson(json as Map<String, dynamic>);
}

class GameChallengeListResponse {
  GameChallengeListResponse(this.challenges, this.currentWeeklyChallenge);
  GameChallengeListResponse.fromJson(Map<String, dynamic> json)
      : challenges = (json['challenges'] as List<dynamic>)
            .map((dynamic val) => GameChallengeInfoDto.fromJson(val as Map<String, dynamic>))
            .toList(),
        currentWeeklyChallenge = GameChallengeInfoDto.fromJson(json['currentWeeklyChallenge'] as Map<String, dynamic>);

  Map<String, dynamic> toJson() => <String, dynamic>{
        'challenges': challenges.map<dynamic>((dynamic val) => val.toJson()).toList(),
        'currentWeeklyChallenge': currentWeeklyChallenge.toJson(),
      };

  List<GameChallengeInfoDto> challenges;
  GameChallengeInfoDto currentWeeklyChallenge;
}

class GameChallengeLocation extends _Location
    with _LocationMixin
    implements GetLocation<GameChallengeDetailsResponse>, PutBodyLocation<GameChallengeRequest, GameChallengeDto> {
  GameChallengeLocation(this.challengeId);
  GameChallengeLocation.fromJson(Map<String, dynamic> json) : challengeId = json['challengeId'] as String;

  Map<String, dynamic> toJson() => <String, dynamic>{
        'challengeId': challengeId,
      };

  @override
  String get path => 'api/game/challenge/{challengeId}'.replaceAll('{challengeId}', this.challengeId);

  String challengeId;
  @override
  GameChallengeDetailsResponse bodyFromGetJson(dynamic json) =>
      GameChallengeDetailsResponse.fromJson(json as Map<String, dynamic>);
  @override
  GameChallengeDto bodyFromPutJson(dynamic json) => GameChallengeDto.fromJson(json as Map<String, dynamic>);
}

class GameChallengeRequest {
  GameChallengeRequest(this.action);
  GameChallengeRequest.fromJson(Map<String, dynamic> json)
      : action = convertGameChallengeActionFromJson(json['action'] as String);

  Map<String, dynamic> toJson() => <String, dynamic>{
        'action': convertGameChallengeActionToJson(action),
      };

  GameChallengeAction action;
}

class GameNotification {
  GameNotification(this.challengeId, /* nullable */ this.inviteToken, this.type);
  GameNotification.fromJson(Map<String, dynamic> json)
      : challengeId = json['challengeId'] as String,
        inviteToken = json['inviteToken'] as String,
        type = convertGameNotificationTypeFromJson(json['type'] as String);

  Map<String, dynamic> toJson() => <String, dynamic>{
        'challengeId': challengeId,
        'inviteToken': inviteToken,
        'type': convertGameNotificationTypeToJson(type),
      };

  String challengeId;
  String inviteToken;
  GameNotificationType type;
}

class GameSimpleSetGuessDto {
  GameSimpleSetGuessDto(this.instrumentKey, this.marketCap);
  GameSimpleSetGuessDto.fromJson(Map<String, dynamic> json)
      : instrumentKey = json['instrumentKey'] as String,
        marketCap = (json['marketCap'] as num).toDouble();

  Map<String, dynamic> toJson() => <String, dynamic>{
        'instrumentKey': instrumentKey,
        'marketCap': marketCap,
      };

  String instrumentKey;
  double marketCap;
}

class GameSimpleSetLocation extends _Location
    with _LocationMixin
    implements
        GetLocation<GameSimpleSetResponse>,
        PostBodyLocation<GameSimpleSetVerifyRequest, GameSimpleSetVerifyResponse> {
  GameSimpleSetLocation();
  GameSimpleSetLocation.fromJson(Map<String, dynamic> json) : super();

  Map<String, dynamic> toJson() => <String, dynamic>{};

  @override
  String get path => 'api/game/simpleGameSet';

  @override
  GameSimpleSetResponse bodyFromGetJson(dynamic json) => GameSimpleSetResponse.fromJson(json as Map<String, dynamic>);
  @override
  GameSimpleSetVerifyResponse bodyFromPostJson(dynamic json) =>
      GameSimpleSetVerifyResponse.fromJson(json as Map<String, dynamic>);
}

class GameSimpleSetResponse {
  GameSimpleSetResponse(this.gameTurnId, this.marketCapScaleMax, this.marketCapScaleMin, this.simpleGame);
  GameSimpleSetResponse.fromJson(Map<String, dynamic> json)
      : gameTurnId = json['gameTurnId'] as String,
        marketCapScaleMax = (json['marketCapScaleMax'] as num).toDouble(),
        marketCapScaleMin = (json['marketCapScaleMin'] as num).toDouble(),
        simpleGame = (json['simpleGame'] as List<dynamic>)
            .map((dynamic val) => SimpleGameDto.fromJson(val as Map<String, dynamic>))
            .toList();

  Map<String, dynamic> toJson() => <String, dynamic>{
        'gameTurnId': gameTurnId,
        'marketCapScaleMax': marketCapScaleMax,
        'marketCapScaleMin': marketCapScaleMin,
        'simpleGame': simpleGame.map<dynamic>((dynamic val) => val.toJson()).toList(),
      };

  String gameTurnId;
  double marketCapScaleMax;
  double marketCapScaleMin;
  List<SimpleGameDto> simpleGame;
}

class GameSimpleSetVerifyRequest {
  GameSimpleSetVerifyRequest(this.gameTurnId, this.guesses);
  GameSimpleSetVerifyRequest.fromJson(Map<String, dynamic> json)
      : gameTurnId = json['gameTurnId'] as String,
        guesses = (json['guesses'] as List<dynamic>)
            .map((dynamic val) => GameSimpleSetGuessDto.fromJson(val as Map<String, dynamic>))
            .toList();

  Map<String, dynamic> toJson() => <String, dynamic>{
        'gameTurnId': gameTurnId,
        'guesses': guesses.map<dynamic>((dynamic val) => val.toJson()).toList(),
      };

  String gameTurnId;
  List<GameSimpleSetGuessDto> guesses;
}

class GameSimpleSetVerifyResponse {
  GameSimpleSetVerifyResponse(
      this.actual, this.correctCount, this.details, this.statsCorrectAnswers, this.statsTotalTurns);
  GameSimpleSetVerifyResponse.fromJson(Map<String, dynamic> json)
      : actual = (json['actual'] as List<dynamic>)
            .map((dynamic val) => GameSimpleSetGuessDto.fromJson(val as Map<String, dynamic>))
            .toList(),
        correctCount = json['correctCount'] as int,
        details = (json['details'] as List<dynamic>)
            .map((dynamic val) => CompanyInfoDetails.fromJson(val as Map<String, dynamic>))
            .toList(),
        statsCorrectAnswers = json['statsCorrectAnswers'] as int,
        statsTotalTurns = json['statsTotalTurns'] as int;

  Map<String, dynamic> toJson() => <String, dynamic>{
        'actual': actual.map<dynamic>((dynamic val) => val.toJson()).toList(),
        'correctCount': correctCount,
        'details': details.map<dynamic>((dynamic val) => val.toJson()).toList(),
        'statsCorrectAnswers': statsCorrectAnswers,
        'statsTotalTurns': statsTotalTurns,
      };

  List<GameSimpleSetGuessDto> actual;
  int correctCount;
  List<CompanyInfoDetails> details;
  int statsCorrectAnswers;
  int statsTotalTurns;
}

class GameUserBaseInfo {
  GameUserBaseInfo(this.avatarUrl, this.displayName);
  GameUserBaseInfo.fromJson(Map<String, dynamic> json)
      : avatarUrl = json['avatarUrl'] as String,
        displayName = json['displayName'] as String;

  Map<String, dynamic> toJson() => <String, dynamic>{
        'avatarUrl': avatarUrl,
        'displayName': displayName,
      };

  String avatarUrl;
  String displayName;
}

class Holding {
  Holding(this.count, this.instrument, this.purchasePriceCurrency, this.purchasePriceValue, this.purchaseSpentCurrency,
      this.purchaseSpentValue);
  Holding.fromJson(Map<String, dynamic> json)
      : count = (json['count'] as num).toDouble(),
        instrument = Instrument.fromJson(json['instrument'] as Map<String, dynamic>),
        purchasePriceCurrency = CurrencyInfo.fromJson(json['purchasePriceCurrency'] as Map<String, dynamic>),
        purchasePriceValue = (json['purchasePriceValue'] as num).toDouble(),
        purchaseSpentCurrency = CurrencyInfo.fromJson(json['purchaseSpentCurrency'] as Map<String, dynamic>),
        purchaseSpentValue = (json['purchaseSpentValue'] as num).toDouble();

  Map<String, dynamic> toJson() => <String, dynamic>{
        'count': count,
        'instrument': instrument.toJson(),
        'purchasePriceCurrency': purchasePriceCurrency.toJson(),
        'purchasePriceValue': purchasePriceValue,
        'purchaseSpentCurrency': purchaseSpentCurrency.toJson(),
        'purchaseSpentValue': purchaseSpentValue,
      };

  double count;
  Instrument instrument;
  CurrencyInfo purchasePriceCurrency;
  double purchasePriceValue;
  CurrencyInfo purchaseSpentCurrency;
  double purchaseSpentValue;
}

class HoldingsListResponse {
  HoldingsListResponse(this.data, this.label);
  HoldingsListResponse.fromJson(Map<String, dynamic> json)
      : data = (json['data'] as List<dynamic>)
            .map((dynamic val) => Holding.fromJson(val as Map<String, dynamic>))
            .toList(),
        label = Label.fromJson(json['label'] as Map<String, dynamic>);

  Map<String, dynamic> toJson() => <String, dynamic>{
        'data': data.map<dynamic>((dynamic val) => val.toJson()).toList(),
        'label': label.toJson(),
      };

  List<Holding> data;
  Label label;
}

class ImageFileLocation extends _Location with _LocationMixin implements GetLocation<dynamic> {
  ImageFileLocation(this.key);
  ImageFileLocation.fromJson(Map<String, dynamic> json) : key = json['key'] as String;

  Map<String, dynamic> toJson() => <String, dynamic>{
        'key': key,
      };

  @override
  String get path => 'api/pricedata/image/{key}'.replaceAll('{key}', this.key);

  String key;
  @override
  dynamic bodyFromGetJson(dynamic json) => json as dynamic;
}

class ImportDryRun extends _Location
    with _LocationMixin
    implements PostBodyLocation<ImportStartRequest, ImportDryRunResponse> {
  ImportDryRun();
  ImportDryRun.fromJson(Map<String, dynamic> json) : super();

  Map<String, dynamic> toJson() => <String, dynamic>{};

  @override
  String get path => 'api/portfolio/import/dryRun';

  @override
  ImportDryRunResponse bodyFromPostJson(dynamic json) => ImportDryRunResponse.fromJson(json as Map<String, dynamic>);
}

class ImportDryRunResponse {
  ImportDryRunResponse(this.collectedErrors, /* nullable */ this.errorResult, this.exampleData, this.exampleHeader);
  ImportDryRunResponse.fromJson(Map<String, dynamic> json)
      : collectedErrors = (json['collectedErrors'] as List<dynamic>)
            .map((dynamic val) => ImportError.fromJson(val as Map<String, dynamic>))
            .toList(),
        errorResult = json['errorResult'] as String,
        exampleData = (json['exampleData'] as List<dynamic>)
            .map((dynamic val) => (val as List<dynamic>).map((dynamic val) => val as String).toList())
            .toList(),
        exampleHeader = (json['exampleHeader'] as List<dynamic>).map((dynamic val) => val as String).toList();

  Map<String, dynamic> toJson() => <String, dynamic>{
        'collectedErrors': collectedErrors.map<dynamic>((dynamic val) => val.toJson()).toList(),
        'errorResult': errorResult,
        'exampleData':
            exampleData.map<dynamic>((dynamic val) => val.map<dynamic>((dynamic val) => val).toList()).toList(),
        'exampleHeader': exampleHeader.map<dynamic>((dynamic val) => val).toList(),
      };

  List<ImportError> collectedErrors;
  String errorResult;
  List<List<String>> exampleData;
  List<String> exampleHeader;
}

class ImportError {
  ImportError(this.error, this.row);
  ImportError.fromJson(Map<String, dynamic> json)
      : error = json['error'] as String,
        row = (json['row'] as List<dynamic>).map((dynamic val) => val as String).toList();

  Map<String, dynamic> toJson() => <String, dynamic>{
        'error': error,
        'row': row.map<dynamic>((dynamic val) => val).toList(),
      };

  String error;
  List<String> row;
}

class ImportInfo extends _Location with _LocationMixin implements GetLocation<UploadTransactionFileResponse> {
  ImportInfo(this.importId);
  ImportInfo.fromJson(Map<String, dynamic> json) : importId = json['importId'] as String;

  Map<String, dynamic> toJson() => <String, dynamic>{
        'importId': importId,
      };

  @override
  String get path => 'api/portfolio/import/info/{importId}'.replaceAll('{importId}', this.importId);

  String importId;
  @override
  UploadTransactionFileResponse bodyFromGetJson(dynamic json) =>
      UploadTransactionFileResponse.fromJson(json as Map<String, dynamic>);
}

class ImportManual extends _Location with _LocationMixin implements PostBodyLocation<ManualImportRequest, String> {
  ImportManual(this.labelToken);
  ImportManual.fromJson(Map<String, dynamic> json) : labelToken = json['labelToken'] as String;

  Map<String, dynamic> toJson() => <String, dynamic>{
        'labelToken': labelToken,
      };

  @override
  String get path => 'api/portfolio/{labelToken}/import/manual'.replaceAll('{labelToken}', this.labelToken);

  String labelToken;
  @override
  String bodyFromPostJson(dynamic json) => json as String;
}

class ImportStart extends _Location
    with _LocationMixin
    implements PostBodyLocation<ImportStartRequest, ImportStartResponse> {
  ImportStart();
  ImportStart.fromJson(Map<String, dynamic> json) : super();

  Map<String, dynamic> toJson() => <String, dynamic>{};

  @override
  String get path => 'api/portfolio/import/start';

  @override
  ImportStartResponse bodyFromPostJson(dynamic json) => ImportStartResponse.fromJson(json as Map<String, dynamic>);
}

class ImportStartRequest {
  ImportStartRequest(/* nullable */ this.customCsvParserConfig, this.importFormat, this.importId);
  ImportStartRequest.fromJson(Map<String, dynamic> json)
      : customCsvParserConfig = json['customCsvParserConfig'] == null
            ? null
            : CustomCsvParserConfig.fromJson(json['customCsvParserConfig'] as Map<String, dynamic>),
        importFormat = convertImportTypeFromJson(json['importFormat'] as String),
        importId = json['importId'] as String;

  Map<String, dynamic> toJson() => <String, dynamic>{
        'customCsvParserConfig': customCsvParserConfig?.toJson(),
        'importFormat': convertImportTypeToJson(importFormat),
        'importId': importId,
      };

  CustomCsvParserConfig customCsvParserConfig;
  ImportType importFormat;
  String importId;
}

class ImportStartResponse {
  ImportStartResponse(this.createdLabel);
  ImportStartResponse.fromJson(Map<String, dynamic> json) : createdLabel = json['createdLabel'] as String;

  Map<String, dynamic> toJson() => <String, dynamic>{
        'createdLabel': createdLabel,
      };

  String createdLabel;
}

class ImportTypeDto {
  ImportTypeDto(this.label, this.type);
  ImportTypeDto.fromJson(Map<String, dynamic> json)
      : label = json['label'] as String,
        type = convertImportTypeFromJson(json['type'] as String);

  Map<String, dynamic> toJson() => <String, dynamic>{
        'label': label,
        'type': convertImportTypeToJson(type),
      };

  String label;
  ImportType type;
}

class InetAddress {
  InetAddress(this.holder, this.canonicalHostName);
  InetAddress.fromJson(Map<String, dynamic> json)
      : holder = InetAddressHolder.fromJson(json['holder'] as Map<String, dynamic>),
        canonicalHostName = json['canonicalHostName'] as String;

  Map<String, dynamic> toJson() => <String, dynamic>{
        'holder': holder.toJson(),
        'canonicalHostName': canonicalHostName,
      };

  InetAddressHolder holder;
  String canonicalHostName;
}

class InetAddressHolder {
  InetAddressHolder(this.originalHostName, this.hostName, this.address, this.family);
  InetAddressHolder.fromJson(Map<String, dynamic> json)
      : originalHostName = json['originalHostName'] as String,
        hostName = json['hostName'] as String,
        address = json['address'] as int,
        family = json['family'] as int;

  Map<String, dynamic> toJson() => <String, dynamic>{
        'originalHostName': originalHostName,
        'hostName': hostName,
        'address': address,
        'family': family,
      };

  String originalHostName;
  String hostName;
  int address;
  int family;
}

class InitPasswordReset extends _Location with _LocationMixin implements PostBodyLocation<InitPasswordResetBody, Unit> {
  InitPasswordReset();
  InitPasswordReset.fromJson(Map<String, dynamic> json) : super();

  Map<String, dynamic> toJson() => <String, dynamic>{};

  @override
  String get path => 'api/auth/initPasswordReset';

  @override
  Unit bodyFromPostJson(dynamic json) => Unit.fromJson(json as Map<String, dynamic>);
}

class InitPasswordResetBody {
  InitPasswordResetBody(this.emailAddress);
  InitPasswordResetBody.fromJson(Map<String, dynamic> json) : emailAddress = json['emailAddress'] as String;

  Map<String, dynamic> toJson() => <String, dynamic>{
        'emailAddress': emailAddress,
      };

  String emailAddress;
}

class Instrument {
  Instrument(
      this.exchange, /* nullable */ this.figi, this.id, this.isin, this.name, this.symbol, this.symbolEod, this.type);
  Instrument.fromJson(Map<String, dynamic> json)
      : exchange = Exchange.fromJson(json['exchange'] as Map<String, dynamic>),
        figi = json['figi'] as String,
        id = json['id'] as String,
        isin = json['isin'] as String,
        name = json['name'] as String,
        symbol = json['symbol'] as String,
        symbolEod = json['symbolEod'] as String,
        type = convertInstrumentTypeFromJson(json['type'] as String);

  Map<String, dynamic> toJson() => <String, dynamic>{
        'exchange': exchange.toJson(),
        'figi': figi,
        'id': id,
        'isin': isin,
        'name': name,
        'symbol': symbol,
        'symbolEod': symbolEod,
        'type': convertInstrumentTypeToJson(type),
      };

  Exchange exchange;
  String figi;
  String id;
  String isin;
  String name;
  String symbol;
  String symbolEod;
  InstrumentType type;
}

class InstrumentBase {
  InstrumentBase(this.symbol, /* nullable */ this.symbolSuffix, this.symbolWithoutSuffix);
  InstrumentBase.fromJson(Map<String, dynamic> json)
      : symbol = json['symbol'] as String,
        symbolSuffix = json['symbolSuffix'] as String,
        symbolWithoutSuffix = json['symbolWithoutSuffix'] as String;

  Map<String, dynamic> toJson() => <String, dynamic>{
        'symbol': symbol,
        'symbolSuffix': symbolSuffix,
        'symbolWithoutSuffix': symbolWithoutSuffix,
      };

  String symbol;
  String symbolSuffix;
  String symbolWithoutSuffix;
}

class InstrumentImageDto {
  InstrumentImageDto(this.fileName, this.height, this.id, this.imageType, this.mimeType, this.width);
  InstrumentImageDto.fromJson(Map<String, dynamic> json)
      : fileName = json['fileName'] as String,
        height = json['height'] as int,
        id = json['id'] as String,
        imageType = convertImageTypeFromJson(json['imageType'] as String),
        mimeType = json['mimeType'] as String,
        width = json['width'] as int;

  Map<String, dynamic> toJson() => <String, dynamic>{
        'fileName': fileName,
        'height': height,
        'id': id,
        'imageType': convertImageTypeToJson(imageType),
        'mimeType': mimeType,
        'width': width,
      };

  String fileName;
  int height;
  String id;
  ImageType imageType;
  String mimeType;
  int width;
}

class InstrumentLogoLocation extends _Location with _LocationMixin implements GetLocation<dynamic> {
  InstrumentLogoLocation(this.key);
  InstrumentLogoLocation.fromJson(Map<String, dynamic> json) : key = json['key'] as String;

  Map<String, dynamic> toJson() => <String, dynamic>{
        'key': key,
      };

  @override
  String get path => 'api/pricedata/instrument/{key}/logo'.replaceAll('{key}', this.key);

  String key;
  @override
  dynamic bodyFromGetJson(dynamic json) => json as dynamic;
}

class Label {
  Label(this.archivedAt, this.id, this.name, this.permissions, this.privacy, this.token, this.type);
  Label.fromJson(Map<String, dynamic> json)
      : archivedAt = InstantWrapper.fromJson(json['archivedAt'] as int),
        id = json['id'] as String,
        name = json['name'] as String,
        permissions = (json['permissions'] as List<dynamic>)
            .map((dynamic val) => Permission.fromJson(val as Map<String, dynamic>))
            .toList(),
        privacy = convertLabelPrivacyFromJson(json['privacy'] as String),
        token = json['token'] as String,
        type = convertLabelTypeFromJson(json['type'] as String);

  Map<String, dynamic> toJson() => <String, dynamic>{
        'archivedAt': archivedAt.toJson(),
        'id': id,
        'name': name,
        'permissions': permissions.map<dynamic>((dynamic val) => val.toJson()).toList(),
        'privacy': convertLabelPrivacyToJson(privacy),
        'token': token,
        'type': convertLabelTypeToJson(type),
      };

  InstantWrapper archivedAt;
  String id;
  String name;
  List<Permission> permissions;
  LabelPrivacy privacy;
  String token;
  LabelType type;
}

class LeaderboardEntry {
  LeaderboardEntry(this.avatarUrl, this.displayName, this.loggedInUser, this.rank, this.statsCorrectAnswers,
      this.statsTotalTurns, this.userToken);
  LeaderboardEntry.fromJson(Map<String, dynamic> json)
      : avatarUrl = json['avatarUrl'] as String,
        displayName = json['displayName'] as String,
        loggedInUser = json['loggedInUser'] as bool,
        rank = json['rank'] as int,
        statsCorrectAnswers = json['statsCorrectAnswers'] as int,
        statsTotalTurns = json['statsTotalTurns'] as int,
        userToken = json['userToken'] as String;

  Map<String, dynamic> toJson() => <String, dynamic>{
        'avatarUrl': avatarUrl,
        'displayName': displayName,
        'loggedInUser': loggedInUser,
        'rank': rank,
        'statsCorrectAnswers': statsCorrectAnswers,
        'statsTotalTurns': statsTotalTurns,
        'userToken': userToken,
      };

  String avatarUrl;
  String displayName;
  bool loggedInUser;
  int rank;
  int statsCorrectAnswers;
  int statsTotalTurns;
  String userToken;
}

class LeaderboardSimpleLocation extends _Location
    with _LocationMixin
    implements GetLocation<LeaderboardSimpleResponse> {
  LeaderboardSimpleLocation(/* nullable */ this.limit);
  LeaderboardSimpleLocation.fromJson(Map<String, dynamic> json) : limit = json['limit'] as int;

  Map<String, dynamic> toJson() => <String, dynamic>{
        'limit': limit,
      };

  @override
  String get path => Uri.parse('api/game/leaderboard/simple').replace(queryParameters: <String, dynamic>{
        if (limit != null) 'limit': limit?.toString(),
      }).toString();

  int limit;
  @override
  LeaderboardSimpleResponse bodyFromGetJson(dynamic json) =>
      LeaderboardSimpleResponse.fromJson(json as Map<String, dynamic>);
}

class LeaderboardSimpleResponse {
  LeaderboardSimpleResponse(this.leaderboardEntries);
  LeaderboardSimpleResponse.fromJson(Map<String, dynamic> json)
      : leaderboardEntries = (json['leaderboardEntries'] as List<dynamic>)
            .map((dynamic val) => LeaderboardEntry.fromJson(val as Map<String, dynamic>))
            .toList();

  Map<String, dynamic> toJson() => <String, dynamic>{
        'leaderboardEntries': leaderboardEntries.map<dynamic>((dynamic val) => val.toJson()).toList(),
      };

  List<LeaderboardEntry> leaderboardEntries;
}

class LogEvent extends _Location with _LocationMixin implements PostBodyLocation<LogEventRequest, Unit> {
  LogEvent();
  LogEvent.fromJson(Map<String, dynamic> json) : super();

  Map<String, dynamic> toJson() => <String, dynamic>{};

  @override
  String get path => 'api/auth/log';

  @override
  Unit bodyFromPostJson(dynamic json) => Unit.fromJson(json as Map<String, dynamic>);
}

class LogEventRequest {
  LogEventRequest(this.email, this.info, this.label);
  LogEventRequest.fromJson(Map<String, dynamic> json)
      : email = json['email'] as String,
        info = (json['info'] as Map<dynamic, dynamic>).map<String, dynamic>(
            (dynamic key, dynamic value) => MapEntry<String, dynamic>(key as String, value as dynamic)),
        label = json['label'] as String;

  Map<String, dynamic> toJson() => <String, dynamic>{
        'email': email,
        'info': info
            .map<String, dynamic>((dynamic key, dynamic value) => MapEntry<String, dynamic>((key) as String, (value))),
        'label': label,
      };

  String email;
  Map<String, dynamic> info;
  String label;
}

class LogShortLinkLocation extends _Location
    with _LocationMixin
    implements PostBodyLocation<LogShortLinkRequest, Unit> {
  LogShortLinkLocation();
  LogShortLinkLocation.fromJson(Map<String, dynamic> json) : super();

  Map<String, dynamic> toJson() => <String, dynamic>{};

  @override
  String get path => 'api/game/challenge/invite/shortlink';

  @override
  Unit bodyFromPostJson(dynamic json) => Unit.fromJson(json as Map<String, dynamic>);
}

class LogShortLinkRequest {
  LogShortLinkRequest(this.inviteToken, this.shortLink);
  LogShortLinkRequest.fromJson(Map<String, dynamic> json)
      : inviteToken = json['inviteToken'] as String,
        shortLink = json['shortLink'] as String;

  Map<String, dynamic> toJson() => <String, dynamic>{
        'inviteToken': inviteToken,
        'shortLink': shortLink,
      };

  String inviteToken;
  String shortLink;
}

class Login extends _Location with _LocationMixin implements PostBodyLocation<LoginRequest, ContextDto> {
  Login();
  Login.fromJson(Map<String, dynamic> json) : super();

  Map<String, dynamic> toJson() => <String, dynamic>{};

  @override
  String get path => 'api/auth/login';

  @override
  ContextDto bodyFromPostJson(dynamic json) => ContextDto.fromJson(json as Map<String, dynamic>);
}

class LoginRequest {
  LoginRequest(this.email, this.password);
  LoginRequest.fromJson(Map<String, dynamic> json)
      : email = json['email'] as String,
        password = json['password'] as String;

  Map<String, dynamic> toJson() => <String, dynamic>{
        'email': email,
        'password': password,
      };

  String email;
  String password;
}

class Logout extends _Location with _LocationMixin implements PostBodyLocation<EmptyRequestDto, ContextDto> {
  Logout();
  Logout.fromJson(Map<String, dynamic> json) : super();

  Map<String, dynamic> toJson() => <String, dynamic>{};

  @override
  String get path => 'api/auth/logout';

  @override
  ContextDto bodyFromPostJson(dynamic json) => ContextDto.fromJson(json as Map<String, dynamic>);
}

class ManualImportRequest {
  ManualImportRequest(this.transactions);
  ManualImportRequest.fromJson(Map<String, dynamic> json)
      : transactions = (json['transactions'] as List<dynamic>)
            .map((dynamic val) => ManualImportTransaction.fromJson(val as Map<String, dynamic>))
            .toList();

  Map<String, dynamic> toJson() => <String, dynamic>{
        'transactions': transactions.map<dynamic>((dynamic val) => val.toJson()).toList(),
      };

  List<ManualImportTransaction> transactions;
}

class ManualImportTransaction {
  ManualImportTransaction(this.count, this.date, this.pricePerShare, this.symbol, this.totalSpent, this.type);
  ManualImportTransaction.fromJson(Map<String, dynamic> json)
      : count = (json['count'] as num).toDouble(),
        date = InstantWrapper.fromJson(json['date'] as int),
        pricePerShare = (json['pricePerShare'] as num).toDouble(),
        symbol = json['symbol'] as String,
        totalSpent = (json['totalSpent'] as num).toDouble(),
        type = convertTransactionTypeFromJson(json['type'] as String);

  Map<String, dynamic> toJson() => <String, dynamic>{
        'count': count,
        'date': date.toJson(),
        'pricePerShare': pricePerShare,
        'symbol': symbol,
        'totalSpent': totalSpent,
        'type': convertTransactionTypeToJson(type),
      };

  double count;
  InstantWrapper date;
  double pricePerShare;
  String symbol;
  double totalSpent;
  TransactionType type;
}

class ParserConfig {
  ParserConfig();
  ParserConfig.fromJson(Map<String, dynamic> json) : super();

  Map<String, dynamic> toJson() => <String, dynamic>{};
}

class PdCompanyInfo {
  PdCompanyInfo(this.description, this.id, this.industries, this.instrument, this.instrumentId, this.label, this.logo,
      this.updatedAt, this.website, /* nullable */ this.wikidataEntityUri, /* nullable */ this.wikipediaArticleUri);
  PdCompanyInfo.fromJson(Map<String, dynamic> json)
      : description = json['description'] as String,
        id = json['id'] as String,
        industries = (json['industries'] as List<dynamic>)
            .map((dynamic val) => PdCompanyInfoIndustry.fromJson(val as Map<String, dynamic>))
            .toList(),
        instrument = PdInstrumentEntity.fromJson(json['instrument'] as Map<String, dynamic>),
        instrumentId = json['instrumentId'] as String,
        label = json['label'] as String,
        logo = URL.fromJson(json['logo'] as Map<String, dynamic>),
        updatedAt = InstantWrapper.fromJson(json['updatedAt'] as int),
        website = URL.fromJson(json['website'] as Map<String, dynamic>),
        wikidataEntityUri = json['wikidataEntityUri'] as String,
        wikipediaArticleUri = json['wikipediaArticleUri'] as String;

  Map<String, dynamic> toJson() => <String, dynamic>{
        'description': description,
        'id': id,
        'industries': industries.map<dynamic>((dynamic val) => val.toJson()).toList(),
        'instrument': instrument.toJson(),
        'instrumentId': instrumentId,
        'label': label,
        'logo': logo.toJson(),
        'updatedAt': updatedAt.toJson(),
        'website': website.toJson(),
        'wikidataEntityUri': wikidataEntityUri,
        'wikipediaArticleUri': wikipediaArticleUri,
      };

  String description;
  String id;
  List<PdCompanyInfoIndustry> industries;
  PdInstrumentEntity instrument;
  String instrumentId;
  String label;
  URL logo;
  InstantWrapper updatedAt;
  URL website;
  String wikidataEntityUri;
  String wikipediaArticleUri;
}

class PdCompanyInfoIndustry {
  PdCompanyInfoIndustry(this.id, this.label, this.wikiDataUri);
  PdCompanyInfoIndustry.fromJson(Map<String, dynamic> json)
      : id = json['id'] as String,
        label = json['label'] as String,
        wikiDataUri = json['wikiDataUri'] as String;

  Map<String, dynamic> toJson() => <String, dynamic>{
        'id': id,
        'label': label,
        'wikiDataUri': wikiDataUri,
      };

  String id;
  String label;
  String wikiDataUri;
}

class PdImageFile {
  PdImageFile(/* nullable */ this.brightnessRatio, this.createdAt, this.fileName, this.id, this.imageData,
      this.imageHeight, this.imageType, this.imageWidth, this.mimeType, this.mimeTypes, this.url);
  PdImageFile.fromJson(Map<String, dynamic> json)
      : brightnessRatio = (json['brightnessRatio'] as num).toDouble(),
        createdAt = InstantWrapper.fromJson(json['createdAt'] as int),
        fileName = json['fileName'] as String,
        id = json['id'] as String,
        imageData = (json['imageData'] as List<dynamic>).map((dynamic val) => val as int).toList(),
        imageHeight = json['imageHeight'] as int,
        imageType = convertImageTypeFromJson(json['imageType'] as String),
        imageWidth = json['imageWidth'] as int,
        mimeType = json['mimeType'] as String,
        mimeTypes = (json['mimeTypes'] as List<dynamic>).map((dynamic val) => val as String).toList(),
        url = json['url'] as String;

  Map<String, dynamic> toJson() => <String, dynamic>{
        'brightnessRatio': brightnessRatio,
        'createdAt': createdAt.toJson(),
        'fileName': fileName,
        'id': id,
        'imageData': imageData.map<dynamic>((dynamic val) => val).toList(),
        'imageHeight': imageHeight,
        'imageType': convertImageTypeToJson(imageType),
        'imageWidth': imageWidth,
        'mimeType': mimeType,
        'mimeTypes': mimeTypes.map<dynamic>((dynamic val) => val).toList(),
        'url': url,
      };

  double brightnessRatio;
  InstantWrapper createdAt;
  String fileName;
  String id;
  List<int> imageData;
  int imageHeight;
  ImageType imageType;
  int imageWidth;
  String mimeType;
  List<String> mimeTypes;
  String url;
}

class PdInstrument implements InstrumentBase {
  PdInstrument(
      this.symbol,
      /* nullable */ this.symbolSuffix,
      this.symbolWithoutSuffix,
      this.createdAt,
      this.currency,
      this.exchange,
      this.exchangeName,
      this.id,
      this.micCompositionCode,
      this.name,
      this.shortName,
      this.snapshot,
      this.type);
  PdInstrument.fromJson(Map<String, dynamic> json)
      : symbol = json['symbol'] as String,
        symbolSuffix = json['symbolSuffix'] as String,
        symbolWithoutSuffix = json['symbolWithoutSuffix'] as String,
        createdAt = InstantWrapper.fromJson(json['createdAt'] as int),
        currency = json['currency'] as String,
        exchange = json['exchange'] as String,
        exchangeName = json['exchangeName'] as String,
        id = json['id'] as String,
        micCompositionCode = json['micCompositionCode'] as String,
        name = json['name'] as String,
        shortName = json['shortName'] as String,
        snapshot = PdInstrumentSnapshot.fromJson(json['snapshot'] as Map<String, dynamic>),
        type = convertPdInstrumentTypeFromJson(json['type'] as String);

  Map<String, dynamic> toJson() => <String, dynamic>{
        'symbol': symbol,
        'symbolSuffix': symbolSuffix,
        'symbolWithoutSuffix': symbolWithoutSuffix,
        'createdAt': createdAt.toJson(),
        'currency': currency,
        'exchange': exchange,
        'exchangeName': exchangeName,
        'id': id,
        'micCompositionCode': micCompositionCode,
        'name': name,
        'shortName': shortName,
        'snapshot': snapshot.toJson(),
        'type': convertPdInstrumentTypeToJson(type),
      };

  String symbol;
  String symbolSuffix;
  String symbolWithoutSuffix;
  InstantWrapper createdAt;
  String currency;
  String exchange;
  String exchangeName;
  String id;
  String micCompositionCode;
  String name;
  String shortName;
  PdInstrumentSnapshot snapshot;
  PdInstrumentType type;
}

class PdInstrumentConfig {
  PdInstrumentConfig(this.id, this.instrument, /* nullable */ this.preferredLogo, /* nullable */ this.wikidataEntity);
  PdInstrumentConfig.fromJson(Map<String, dynamic> json)
      : id = json['id'] as String,
        instrument = PdInstrumentEntity.fromJson(json['instrument'] as Map<String, dynamic>),
        preferredLogo =
            json['preferredLogo'] == null ? null : PdImageFile.fromJson(json['preferredLogo'] as Map<String, dynamic>),
        wikidataEntity = json['wikidataEntity'] as String;

  Map<String, dynamic> toJson() => <String, dynamic>{
        'id': id,
        'instrument': instrument.toJson(),
        'preferredLogo': preferredLogo?.toJson(),
        'wikidataEntity': wikidataEntity,
      };

  String id;
  PdInstrumentEntity instrument;
  PdImageFile preferredLogo;
  String wikidataEntity;
}

class PdInstrumentDto {
  PdInstrumentDto(
      this.currencyCode, this.id, this.marketCap, this.name, this.symbol, this.type, this.volume, this.website);
  PdInstrumentDto.fromJson(Map<String, dynamic> json)
      : currencyCode = json['currencyCode'] as String,
        id = json['id'] as String,
        marketCap = (json['marketCap'] as num).toDouble(),
        name = json['name'] as String,
        symbol = json['symbol'] as String,
        type = convertPdInstrumentTypeFromJson(json['type'] as String),
        volume = (json['volume'] as num).toDouble(),
        website = json['website'] as String;

  Map<String, dynamic> toJson() => <String, dynamic>{
        'currencyCode': currencyCode,
        'id': id,
        'marketCap': marketCap,
        'name': name,
        'symbol': symbol,
        'type': convertPdInstrumentTypeToJson(type),
        'volume': volume,
        'website': website,
      };

  String currencyCode;
  String id;
  double marketCap;
  String name;
  String symbol;
  PdInstrumentType type;
  double volume;
  String website;
}

class PdInstrumentEntity implements InstrumentBase {
  PdInstrumentEntity(
      this.symbol,
      /* nullable */ this.symbolSuffix,
      this.symbolWithoutSuffix,
      this.companyImagesLastFetched,
      this.companyInfoLastFetched,
      this.companyName,
      this.companyWebsite,
      /* nullable */ this.companyWebsiteUrl,
      /* nullable */ this.config,
      this.filledEodEnd,
      this.filledEodStart,
      this.id,
      this.images,
      /* nullable */ this.lastStockSnapshot,
      this.type);
  PdInstrumentEntity.fromJson(Map<String, dynamic> json)
      : symbol = json['symbol'] as String,
        symbolSuffix = json['symbolSuffix'] as String,
        symbolWithoutSuffix = json['symbolWithoutSuffix'] as String,
        companyImagesLastFetched = InstantWrapper.fromJson(json['companyImagesLastFetched'] as int),
        companyInfoLastFetched = InstantWrapper.fromJson(json['companyInfoLastFetched'] as int),
        companyName = json['companyName'] as String,
        companyWebsite = json['companyWebsite'] as String,
        companyWebsiteUrl =
            json['companyWebsiteUrl'] == null ? null : URL.fromJson(json['companyWebsiteUrl'] as Map<String, dynamic>),
        config = json['config'] == null ? null : PdInstrumentConfig.fromJson(json['config'] as Map<String, dynamic>),
        filledEodEnd = json['filledEodEnd'] as /* yyyy-mm-dd date LocalDate */ String,
        filledEodStart = json['filledEodStart'] as /* yyyy-mm-dd date LocalDate */ String,
        id = json['id'] as String,
        images = (json['images'] as List<dynamic>)
            .map((dynamic val) => PdInstrumentImage.fromJson(val as Map<String, dynamic>))
            .toList(),
        lastStockSnapshot = json['lastStockSnapshot'] == null
            ? null
            : PdStockDataSnapshotEntity.fromJson(json['lastStockSnapshot'] as Map<String, dynamic>),
        type = convertPdInstrumentTypeFromJson(json['type'] as String);

  Map<String, dynamic> toJson() => <String, dynamic>{
        'symbol': symbol,
        'symbolSuffix': symbolSuffix,
        'symbolWithoutSuffix': symbolWithoutSuffix,
        'companyImagesLastFetched': companyImagesLastFetched.toJson(),
        'companyInfoLastFetched': companyInfoLastFetched.toJson(),
        'companyName': companyName,
        'companyWebsite': companyWebsite,
        'companyWebsiteUrl': companyWebsiteUrl?.toJson(),
        'config': config?.toJson(),
        'filledEodEnd': filledEodEnd,
        'filledEodStart': filledEodStart,
        'id': id,
        'images': images.map<dynamic>((dynamic val) => val.toJson()).toList(),
        'lastStockSnapshot': lastStockSnapshot?.toJson(),
        'type': convertPdInstrumentTypeToJson(type),
      };

  String symbol;
  String symbolSuffix;
  String symbolWithoutSuffix;
  InstantWrapper companyImagesLastFetched;
  InstantWrapper companyInfoLastFetched;
  String companyName;
  String companyWebsite;
  URL companyWebsiteUrl;
  PdInstrumentConfig config;
  /* yyyy-mm-dd date LocalDate */ String filledEodEnd;
  /* yyyy-mm-dd date LocalDate */ String filledEodStart;
  String id;
  List<PdInstrumentImage> images;
  PdStockDataSnapshotEntity lastStockSnapshot;
  PdInstrumentType type;
}

class PdInstrumentImage {
  PdInstrumentImage(this.id, this.imageFile, this.instrument);
  PdInstrumentImage.fromJson(Map<String, dynamic> json)
      : id = PdInstrumentImageId.fromJson(json['id'] as Map<String, dynamic>),
        imageFile = PdImageFile.fromJson(json['imageFile'] as Map<String, dynamic>),
        instrument = PdInstrumentEntity.fromJson(json['instrument'] as Map<String, dynamic>);

  Map<String, dynamic> toJson() => <String, dynamic>{
        'id': id.toJson(),
        'imageFile': imageFile.toJson(),
        'instrument': instrument.toJson(),
      };

  PdInstrumentImageId id;
  PdImageFile imageFile;
  PdInstrumentEntity instrument;
}

class PdInstrumentImageId {
  PdInstrumentImageId(this.imageFileId, this.instrumentId);
  PdInstrumentImageId.fromJson(Map<String, dynamic> json)
      : imageFileId = json['imageFileId'] as String,
        instrumentId = json['instrumentId'] as String;

  Map<String, dynamic> toJson() => <String, dynamic>{
        'imageFileId': imageFileId,
        'instrumentId': instrumentId,
      };

  String imageFileId;
  String instrumentId;
}

class PdInstrumentSnapshot {
  PdInstrumentSnapshot(this.regularMarketPrice, /* nullable */ this.stockStats, this.volume);
  PdInstrumentSnapshot.fromJson(Map<String, dynamic> json)
      : regularMarketPrice = (json['regularMarketPrice'] as num).toDouble(),
        stockStats =
            json['stockStats'] == null ? null : PdStockStats.fromJson(json['stockStats'] as Map<String, dynamic>),
        volume = (json['volume'] as num).toDouble();

  Map<String, dynamic> toJson() => <String, dynamic>{
        'regularMarketPrice': regularMarketPrice,
        'stockStats': stockStats?.toJson(),
        'volume': volume,
      };

  double regularMarketPrice;
  PdStockStats stockStats;
  double volume;
}

class PdStockDataSnapshotEntity {
  PdStockDataSnapshotEntity(
      this.currency,
      this.date,
      this.epsForward,
      this.epsTrailing,
      /* nullable */ this.exchangeName,
      this.floatShares,
      this.id,
      this.instrument,
      this.lastSplitDate,
      /* nullable */ this.lastSplitFactor,
      this.marketCap,
      /* nullable */ this.micCompositionCode,
      this.peForward,
      this.peTrailing,
      this.profitMargins,
      this.regularMarketPrice,
      this.sharesOutstanding,
      this.sharesShort,
      this.volume);
  PdStockDataSnapshotEntity.fromJson(Map<String, dynamic> json)
      : currency = Currency.fromJson(json['currency'] as Map<String, dynamic>),
        date = InstantWrapper.fromJson(json['date'] as int),
        epsForward = (json['epsForward'] as num).toDouble(),
        epsTrailing = (json['epsTrailing'] as num).toDouble(),
        exchangeName = json['exchangeName'] as String,
        floatShares = (json['floatShares'] as num).toDouble(),
        id = json['id'] as String,
        instrument = PdInstrumentEntity.fromJson(json['instrument'] as Map<String, dynamic>),
        lastSplitDate = InstantWrapper.fromJson(json['lastSplitDate'] as int),
        lastSplitFactor = json['lastSplitFactor'] as String,
        marketCap = (json['marketCap'] as num).toDouble(),
        micCompositionCode = json['micCompositionCode'] as String,
        peForward = (json['peForward'] as num).toDouble(),
        peTrailing = (json['peTrailing'] as num).toDouble(),
        profitMargins = (json['profitMargins'] as num).toDouble(),
        regularMarketPrice = (json['regularMarketPrice'] as num).toDouble(),
        sharesOutstanding = (json['sharesOutstanding'] as num).toDouble(),
        sharesShort = (json['sharesShort'] as num).toDouble(),
        volume = (json['volume'] as num).toDouble();

  Map<String, dynamic> toJson() => <String, dynamic>{
        'currency': currency.toJson(),
        'date': date.toJson(),
        'epsForward': epsForward,
        'epsTrailing': epsTrailing,
        'exchangeName': exchangeName,
        'floatShares': floatShares,
        'id': id,
        'instrument': instrument.toJson(),
        'lastSplitDate': lastSplitDate.toJson(),
        'lastSplitFactor': lastSplitFactor,
        'marketCap': marketCap,
        'micCompositionCode': micCompositionCode,
        'peForward': peForward,
        'peTrailing': peTrailing,
        'profitMargins': profitMargins,
        'regularMarketPrice': regularMarketPrice,
        'sharesOutstanding': sharesOutstanding,
        'sharesShort': sharesShort,
        'volume': volume,
      };

  Currency currency;
  InstantWrapper date;
  double epsForward;
  double epsTrailing;
  String exchangeName;
  double floatShares;
  String id;
  PdInstrumentEntity instrument;
  InstantWrapper lastSplitDate;
  String lastSplitFactor;
  double marketCap;
  String micCompositionCode;
  double peForward;
  double peTrailing;
  double profitMargins;
  double regularMarketPrice;
  double sharesOutstanding;
  double sharesShort;
  double volume;
}

class PdStockStats {
  PdStockStats(this.floatShares, this.marketCap, this.sharesOutstanding);
  PdStockStats.fromJson(Map<String, dynamic> json)
      : floatShares = (json['floatShares'] as num).toDouble(),
        marketCap = (json['marketCap'] as num).toDouble(),
        sharesOutstanding = (json['sharesOutstanding'] as num).toDouble();

  Map<String, dynamic> toJson() => <String, dynamic>{
        'floatShares': floatShares,
        'marketCap': marketCap,
        'sharesOutstanding': sharesOutstanding,
      };

  double floatShares;
  double marketCap;
  double sharesOutstanding;
}

class Permission {
  Permission(this.id, this.label, this.type, this.user);
  Permission.fromJson(Map<String, dynamic> json)
      : id = json['id'] as String,
        label = Label.fromJson(json['label'] as Map<String, dynamic>),
        type = convertPermissionTypeFromJson(json['type'] as String),
        user = UserInfo.fromJson(json['user'] as Map<String, dynamic>);

  Map<String, dynamic> toJson() => <String, dynamic>{
        'id': id,
        'label': label.toJson(),
        'type': convertPermissionTypeToJson(type),
        'user': user.toJson(),
      };

  String id;
  Label label;
  PermissionType type;
  UserInfo user;
}

class PortfolioCreateRequest {
  PortfolioCreateRequest(/* nullable */ this.name);
  PortfolioCreateRequest.fromJson(Map<String, dynamic> json) : name = json['name'] as String;

  Map<String, dynamic> toJson() => <String, dynamic>{
        'name': name,
      };

  String name;
}

class PortfolioLabel extends _Location
    with _LocationMixin
    implements GetLocation<PortfolioTransactionListResponse>, PutBodyLocation<PortfolioLabelUpdateRequest, String> {
  PortfolioLabel(this.labelToken);
  PortfolioLabel.fromJson(Map<String, dynamic> json) : labelToken = json['labelToken'] as String;

  Map<String, dynamic> toJson() => <String, dynamic>{
        'labelToken': labelToken,
      };

  @override
  String get path => 'api/portfolio/{labelToken}'.replaceAll('{labelToken}', this.labelToken);

  String labelToken;
  @override
  PortfolioTransactionListResponse bodyFromGetJson(dynamic json) =>
      PortfolioTransactionListResponse.fromJson(json as Map<String, dynamic>);
  @override
  String bodyFromPutJson(dynamic json) => json as String;
}

class PortfolioLabelHoldings extends _Location with _LocationMixin implements GetLocation<HoldingsListResponse> {
  PortfolioLabelHoldings(this.labelToken);
  PortfolioLabelHoldings.fromJson(Map<String, dynamic> json) : labelToken = json['labelToken'] as String;

  Map<String, dynamic> toJson() => <String, dynamic>{
        'labelToken': labelToken,
      };

  @override
  String get path => 'api/portfolio/{labelToken}/holdings'.replaceAll('{labelToken}', this.labelToken);

  String labelToken;
  @override
  HoldingsListResponse bodyFromGetJson(dynamic json) => HoldingsListResponse.fromJson(json as Map<String, dynamic>);
}

class PortfolioLabelUpdateRequest {
  PortfolioLabelUpdateRequest(/* nullable */ this.archived, this.labelName, this.privacy);
  PortfolioLabelUpdateRequest.fromJson(Map<String, dynamic> json)
      : archived = json['archived'] as bool,
        labelName = json['labelName'] as String,
        privacy = convertLabelPrivacyFromJson(json['privacy'] as String);

  Map<String, dynamic> toJson() => <String, dynamic>{
        'archived': archived,
        'labelName': labelName,
        'privacy': convertLabelPrivacyToJson(privacy),
      };

  bool archived;
  String labelName;
  LabelPrivacy privacy;
}

class PortfolioList extends _Location
    with _LocationMixin
    implements GetLocation<PortfolioListResponse>, PostBodyLocation<PortfolioCreateRequest, String> {
  PortfolioList();
  PortfolioList.fromJson(Map<String, dynamic> json) : super();

  Map<String, dynamic> toJson() => <String, dynamic>{};

  @override
  String get path => 'api/portfolio';

  @override
  PortfolioListResponse bodyFromGetJson(dynamic json) => PortfolioListResponse.fromJson(json as Map<String, dynamic>);
  @override
  String bodyFromPostJson(dynamic json) => json as String;
}

class PortfolioListResponse {
  PortfolioListResponse(this.data);
  PortfolioListResponse.fromJson(Map<String, dynamic> json)
      : data =
            (json['data'] as List<dynamic>).map((dynamic val) => Label.fromJson(val as Map<String, dynamic>)).toList();

  Map<String, dynamic> toJson() => <String, dynamic>{
        'data': data.map<dynamic>((dynamic val) => val.toJson()).toList(),
      };

  List<Label> data;
}

class PortfolioTransactionListResponse {
  PortfolioTransactionListResponse(this.data, this.label);
  PortfolioTransactionListResponse.fromJson(Map<String, dynamic> json)
      : data = (json['data'] as List<dynamic>)
            .map((dynamic val) => Transaction.fromJson(val as Map<String, dynamic>))
            .toList(),
        label = Label.fromJson(json['label'] as Map<String, dynamic>);

  Map<String, dynamic> toJson() => <String, dynamic>{
        'data': data.map<dynamic>((dynamic val) => val.toJson()).toList(),
        'label': label.toJson(),
      };

  List<Transaction> data;
  Label label;
}

class RegisterDeviceLocation extends _Location
    with _LocationMixin
    implements PostBodyLocation<RegisterDeviceRequest, RegisterDeviceResponse> {
  RegisterDeviceLocation();
  RegisterDeviceLocation.fromJson(Map<String, dynamic> json) : super();

  Map<String, dynamic> toJson() => <String, dynamic>{};

  @override
  String get path => 'api/game/registerDevice';

  @override
  RegisterDeviceResponse bodyFromPostJson(dynamic json) =>
      RegisterDeviceResponse.fromJson(json as Map<String, dynamic>);
}

class RegisterDeviceRequest {
  RegisterDeviceRequest(this.deviceInfo, this.osInfo, this.platform);
  RegisterDeviceRequest.fromJson(Map<String, dynamic> json)
      : deviceInfo = json['deviceInfo'] as String,
        osInfo = json['osInfo'] as String,
        platform = convertDevicePlatformFromJson(json['platform'] as String);

  Map<String, dynamic> toJson() => <String, dynamic>{
        'deviceInfo': deviceInfo,
        'osInfo': osInfo,
        'platform': convertDevicePlatformToJson(platform),
      };

  String deviceInfo;
  String osInfo;
  DevicePlatform platform;
}

class RegisterDeviceResponse {
  RegisterDeviceResponse(this.deviceKey, this.userKey);
  RegisterDeviceResponse.fromJson(Map<String, dynamic> json)
      : deviceKey = json['deviceKey'] as String,
        userKey = json['userKey'] as String;

  Map<String, dynamic> toJson() => <String, dynamic>{
        'deviceKey': deviceKey,
        'userKey': userKey,
      };

  String deviceKey;
  String userKey;
}

class SignUp extends _Location with _LocationMixin implements PostBodyLocation<SignUpRequest, Unit> {
  SignUp();
  SignUp.fromJson(Map<String, dynamic> json) : super();

  Map<String, dynamic> toJson() => <String, dynamic>{};

  @override
  String get path => 'api/auth/signup';

  @override
  Unit bodyFromPostJson(dynamic json) => Unit.fromJson(json as Map<String, dynamic>);
}

class SignUpRequest {
  SignUpRequest(this.email, this.password);
  SignUpRequest.fromJson(Map<String, dynamic> json)
      : email = json['email'] as String,
        password = json['password'] as String;

  Map<String, dynamic> toJson() => <String, dynamic>{
        'email': email,
        'password': password,
      };

  String email;
  String password;
}

class SimpleGameDto {
  SimpleGameDto(this.instrumentKey, this.logo, this.symbol);
  SimpleGameDto.fromJson(Map<String, dynamic> json)
      : instrumentKey = json['instrumentKey'] as String,
        logo = InstrumentImageDto.fromJson(json['logo'] as Map<String, dynamic>),
        symbol = json['symbol'] as String;

  Map<String, dynamic> toJson() => <String, dynamic>{
        'instrumentKey': instrumentKey,
        'logo': logo.toJson(),
        'symbol': symbol,
      };

  String instrumentKey;
  InstrumentImageDto logo;
  String symbol;
}

class StatsSummary extends _Location with _LocationMixin implements GetLocation<StatsSummaryResponse> {
  StatsSummary(this.endDate, this.startDate, this.type);
  StatsSummary.fromJson(Map<String, dynamic> json)
      : endDate = json['endDate'] as /* yyyy-mm-dd date LocalDate */ String,
        startDate = json['startDate'] as /* yyyy-mm-dd date LocalDate */ String,
        type = convertStatsTypeFromJson(json['type'] as String);

  Map<String, dynamic> toJson() => <String, dynamic>{
        'endDate': endDate,
        'startDate': startDate,
        'type': convertStatsTypeToJson(type),
      };

  @override
  String get path => Uri.parse('api/pricedata/stats').replace(queryParameters: <String, dynamic>{
        'endDate': endDate?.toString(),
        'startDate': startDate?.toString(),
        'type': type,
      }).toString();

  /* yyyy-mm-dd date LocalDate */ String endDate;
  /* yyyy-mm-dd date LocalDate */ String startDate;
  StatsType type;
  @override
  StatsSummaryResponse bodyFromGetJson(dynamic json) => StatsSummaryResponse.fromJson(json as Map<String, dynamic>);
}

class StatsSummaryResponse {
  StatsSummaryResponse(this.yearMoveShares);
  StatsSummaryResponse.fromJson(Map<String, dynamic> json)
      : yearMoveShares = (json['yearMoveShares'] as List<dynamic>)
            .map((dynamic val) => YearMoverShares.fromJson(val as Map<String, dynamic>))
            .toList();

  Map<String, dynamic> toJson() => <String, dynamic>{
        'yearMoveShares': yearMoveShares.map<dynamic>((dynamic val) => val.toJson()).toList(),
      };

  List<YearMoverShares> yearMoveShares;
}

class StatusLocation extends _Location with _LocationMixin implements GetLocation<StatusResponseDto> {
  StatusLocation();
  StatusLocation.fromJson(Map<String, dynamic> json) : super();

  Map<String, dynamic> toJson() => <String, dynamic>{};

  @override
  String get path => 'api/status';

  @override
  StatusResponseDto bodyFromGetJson(dynamic json) => StatusResponseDto.fromJson(json as Map<String, dynamic>);
}

class StatusResponseDto {
  StatusResponseDto(this.appMetrics, this.build, this.jvmMetrics);
  StatusResponseDto.fromJson(Map<String, dynamic> json)
      : appMetrics = AppMetricsDto.fromJson(json['appMetrics'] as Map<String, dynamic>),
        build = json['build'] as String,
        jvmMetrics = (json['jvmMetrics'] as Map<dynamic, dynamic>).map<String, dynamic>(
            (dynamic key, dynamic value) => MapEntry<String, dynamic>(key as String, value as dynamic));

  Map<String, dynamic> toJson() => <String, dynamic>{
        'appMetrics': appMetrics.toJson(),
        'build': build,
        'jvmMetrics': jvmMetrics
            .map<String, dynamic>((dynamic key, dynamic value) => MapEntry<String, dynamic>((key) as String, (value))),
      };

  AppMetricsDto appMetrics;
  String build;
  Map<String, dynamic> jvmMetrics;
}

class SymbolInfo extends _Location with _LocationMixin implements GetLocation<SymbolInfoResponse> {
  SymbolInfo(this.symbols);
  SymbolInfo.fromJson(Map<String, dynamic> json)
      : symbols = (json['symbols'] as List<dynamic>).map((dynamic val) => val as String).toList();

  Map<String, dynamic> toJson() => <String, dynamic>{
        'symbols': symbols.map<dynamic>((dynamic val) => val).toList(),
      };

  @override
  String get path => Uri.parse('api/pricedata/symbolInfos').replace(queryParameters: <String, dynamic>{
        'symbols': symbols,
      }).toString();

  List<String> symbols;
  @override
  SymbolInfoResponse bodyFromGetJson(dynamic json) => SymbolInfoResponse.fromJson(json as Map<String, dynamic>);
}

class SymbolInfoResponse {
  SymbolInfoResponse(this.companyInfos);
  SymbolInfoResponse.fromJson(Map<String, dynamic> json)
      : companyInfos = (json['companyInfos'] as Map<dynamic, dynamic>).map<String, PdCompanyInfo>(
            (dynamic key, dynamic value) =>
                MapEntry<String, PdCompanyInfo>(key as String, PdCompanyInfo.fromJson(value as Map<String, dynamic>)));

  Map<String, dynamic> toJson() => <String, dynamic>{
        'companyInfos': companyInfos.map<String, dynamic>(
            (dynamic key, dynamic value) => MapEntry<String, dynamic>((key) as String, (value.toJson()))),
      };

  Map<String, PdCompanyInfo> companyInfos;
}

class SymbolSearch extends _Location with _LocationMixin implements GetLocation<SymbolSearchResponse> {
  SymbolSearch(this.query);
  SymbolSearch.fromJson(Map<String, dynamic> json) : query = json['query'] as String;

  Map<String, dynamic> toJson() => <String, dynamic>{
        'query': query,
      };

  @override
  String get path => Uri.parse('api/pricedata/search').replace(queryParameters: <String, dynamic>{
        'query': query?.toString(),
      }).toString();

  String query;
  @override
  SymbolSearchResponse bodyFromGetJson(dynamic json) => SymbolSearchResponse.fromJson(json as Map<String, dynamic>);
}

class SymbolSearchResponse {
  SymbolSearchResponse(this.snapshot);
  SymbolSearchResponse.fromJson(Map<String, dynamic> json)
      : snapshot = (json['snapshot'] as List<dynamic>)
            .map((dynamic val) => PdInstrument.fromJson(val as Map<String, dynamic>))
            .toList();

  Map<String, dynamic> toJson() => <String, dynamic>{
        'snapshot': snapshot.map<dynamic>((dynamic val) => val.toJson()).toList(),
      };

  List<PdInstrument> snapshot;
}

class TestMethodGetResponse {
  TestMethodGetResponse(this.tmp);
  TestMethodGetResponse.fromJson(Map<String, dynamic> json) : tmp = json['tmp'] as String;

  Map<String, dynamic> toJson() => <String, dynamic>{
        'tmp': tmp,
      };

  String tmp;
}

class TestMethodLocation extends _Location
    with _LocationMixin
    implements
        GetLocation<TestMethodGetResponse>,
        PostBodyLocation<TestMethodPostRequest, TestMethodPostResponse>,
        PutBodyLocation<TestMethodPutRequest, TestMethodPutResponse> {
  TestMethodLocation(this.param);
  TestMethodLocation.fromJson(Map<String, dynamic> json) : param = json['param'] as String;

  Map<String, dynamic> toJson() => <String, dynamic>{
        'param': param,
      };

  @override
  String get path => 'api/test/method/{param}'.replaceAll('{param}', this.param);

  String param;
  @override
  TestMethodGetResponse bodyFromGetJson(dynamic json) => TestMethodGetResponse.fromJson(json as Map<String, dynamic>);
  @override
  TestMethodPostResponse bodyFromPostJson(dynamic json) =>
      TestMethodPostResponse.fromJson(json as Map<String, dynamic>);
  @override
  TestMethodPutResponse bodyFromPutJson(dynamic json) => TestMethodPutResponse.fromJson(json as Map<String, dynamic>);
}

class TestMethodPostRequest {
  TestMethodPostRequest(this.tmp);
  TestMethodPostRequest.fromJson(Map<String, dynamic> json) : tmp = json['tmp'] as String;

  Map<String, dynamic> toJson() => <String, dynamic>{
        'tmp': tmp,
      };

  String tmp;
}

class TestMethodPostResponse {
  TestMethodPostResponse(this.tmp);
  TestMethodPostResponse.fromJson(Map<String, dynamic> json) : tmp = json['tmp'] as String;

  Map<String, dynamic> toJson() => <String, dynamic>{
        'tmp': tmp,
      };

  String tmp;
}

class TestMethodPutRequest {
  TestMethodPutRequest(this.tmp);
  TestMethodPutRequest.fromJson(Map<String, dynamic> json) : tmp = json['tmp'] as String;

  Map<String, dynamic> toJson() => <String, dynamic>{
        'tmp': tmp,
      };

  String tmp;
}

class TestMethodPutResponse {
  TestMethodPutResponse(this.tmp);
  TestMethodPutResponse.fromJson(Map<String, dynamic> json) : tmp = json['tmp'] as String;

  Map<String, dynamic> toJson() => <String, dynamic>{
        'tmp': tmp,
      };

  String tmp;
}

class Transaction {
  Transaction(
      this.count, this.createdAt, this.id, this.instrument, this.label, this.transactionAt, this.type, this.values);
  Transaction.fromJson(Map<String, dynamic> json)
      : count = (json['count'] as num).toDouble(),
        createdAt = InstantWrapper.fromJson(json['createdAt'] as int),
        id = json['id'] as String,
        instrument = Instrument.fromJson(json['instrument'] as Map<String, dynamic>),
        label = Label.fromJson(json['label'] as Map<String, dynamic>),
        transactionAt = InstantWrapper.fromJson(json['transactionAt'] as int),
        type = convertTransactionTypeFromJson(json['type'] as String),
        values = (json['values'] as List<dynamic>)
            .map((dynamic val) => TransactionValue.fromJson(val as Map<String, dynamic>))
            .toList();

  Map<String, dynamic> toJson() => <String, dynamic>{
        'count': count,
        'createdAt': createdAt.toJson(),
        'id': id,
        'instrument': instrument.toJson(),
        'label': label.toJson(),
        'transactionAt': transactionAt.toJson(),
        'type': convertTransactionTypeToJson(type),
        'values': values.map<dynamic>((dynamic val) => val.toJson()).toList(),
      };

  double count;
  InstantWrapper createdAt;
  String id;
  Instrument instrument;
  Label label;
  InstantWrapper transactionAt;
  TransactionType type;
  List<TransactionValue> values;
}

class TransactionValue {
  TransactionValue(this.amount, this.currency, this.id, this.transaction, this.type);
  TransactionValue.fromJson(Map<String, dynamic> json)
      : amount = (json['amount'] as num).toDouble(),
        currency = CurrencyInfo.fromJson(json['currency'] as Map<String, dynamic>),
        id = json['id'] as String,
        transaction = Transaction.fromJson(json['transaction'] as Map<String, dynamic>),
        type = convertTransactionValueTypeFromJson(json['type'] as String);

  Map<String, dynamic> toJson() => <String, dynamic>{
        'amount': amount,
        'currency': currency.toJson(),
        'id': id,
        'transaction': transaction.toJson(),
        'type': convertTransactionValueTypeToJson(type),
      };

  double amount;
  CurrencyInfo currency;
  String id;
  Transaction transaction;
  TransactionValueType type;
}

class URI {
  URI(
      this.scheme,
      this.fragment,
      this.authority,
      this.userInfo,
      this.host,
      this.port,
      this.path,
      this.query,
      this.schemeSpecificPart,
      this.hash,
      this.decodedUserInfo,
      this.decodedAuthority,
      this.decodedPath,
      this.decodedQuery,
      this.decodedFragment,
      this.decodedSchemeSpecificPart);
  URI.fromJson(Map<String, dynamic> json)
      : scheme = json['scheme'] as String,
        fragment = json['fragment'] as String,
        authority = json['authority'] as String,
        userInfo = json['userInfo'] as String,
        host = json['host'] as String,
        port = json['port'] as int,
        path = json['path'] as String,
        query = json['query'] as String,
        schemeSpecificPart = json['schemeSpecificPart'] as String,
        hash = json['hash'] as int,
        decodedUserInfo = json['decodedUserInfo'] as String,
        decodedAuthority = json['decodedAuthority'] as String,
        decodedPath = json['decodedPath'] as String,
        decodedQuery = json['decodedQuery'] as String,
        decodedFragment = json['decodedFragment'] as String,
        decodedSchemeSpecificPart = json['decodedSchemeSpecificPart'] as String;

  Map<String, dynamic> toJson() => <String, dynamic>{
        'scheme': scheme,
        'fragment': fragment,
        'authority': authority,
        'userInfo': userInfo,
        'host': host,
        'port': port,
        'path': path,
        'query': query,
        'schemeSpecificPart': schemeSpecificPart,
        'hash': hash,
        'decodedUserInfo': decodedUserInfo,
        'decodedAuthority': decodedAuthority,
        'decodedPath': decodedPath,
        'decodedQuery': decodedQuery,
        'decodedFragment': decodedFragment,
        'decodedSchemeSpecificPart': decodedSchemeSpecificPart,
      };

  String scheme;
  String fragment;
  String authority;
  String userInfo;
  String host;
  int port;
  String path;
  String query;
  String schemeSpecificPart;
  int hash;
  String decodedUserInfo;
  String decodedAuthority;
  String decodedPath;
  String decodedQuery;
  String decodedFragment;
  String decodedSchemeSpecificPart;
}

class URL {
  URL(this.protocol, this.host, this.port, this.file, this.query, this.authority, this.path, this.userInfo, this.ref,
      this.hostAddress, this.handler, this.tempState);
  URL.fromJson(Map<String, dynamic> json)
      : protocol = json['protocol'] as String,
        host = json['host'] as String,
        port = json['port'] as int,
        file = json['file'] as String,
        query = json['query'] as String,
        authority = json['authority'] as String,
        path = json['path'] as String,
        userInfo = json['userInfo'] as String,
        ref = json['ref'] as String,
        hostAddress = InetAddress.fromJson(json['hostAddress'] as Map<String, dynamic>),
        handler = URLStreamHandler.fromJson(json['handler'] as Map<String, dynamic>),
        tempState = UrlDeserializedState.fromJson(json['tempState'] as Map<String, dynamic>);

  Map<String, dynamic> toJson() => <String, dynamic>{
        'protocol': protocol,
        'host': host,
        'port': port,
        'file': file,
        'query': query,
        'authority': authority,
        'path': path,
        'userInfo': userInfo,
        'ref': ref,
        'hostAddress': hostAddress.toJson(),
        'handler': handler.toJson(),
        'tempState': tempState.toJson(),
      };

  String protocol;
  String host;
  int port;
  String file;
  String query;
  String authority;
  String path;
  String userInfo;
  String ref;
  InetAddress hostAddress;
  URLStreamHandler handler;
  UrlDeserializedState tempState;
}

class URLStreamHandler {
  URLStreamHandler();
  URLStreamHandler.fromJson(Map<String, dynamic> json) : super();

  Map<String, dynamic> toJson() => <String, dynamic>{};
}

class UpdateProfile extends _Location with _LocationMixin implements PostBodyLocation<UpdateProfileBody, ContextDto> {
  UpdateProfile();
  UpdateProfile.fromJson(Map<String, dynamic> json) : super();

  Map<String, dynamic> toJson() => <String, dynamic>{};

  @override
  String get path => 'api/auth/profile/update';

  @override
  ContextDto bodyFromPostJson(dynamic json) => ContextDto.fromJson(json as Map<String, dynamic>);
}

class UpdateProfileBody {
  UpdateProfileBody(/* nullable */ this.passwordChange);
  UpdateProfileBody.fromJson(Map<String, dynamic> json) : passwordChange = json['passwordChange'] as String;

  Map<String, dynamic> toJson() => <String, dynamic>{
        'passwordChange': passwordChange,
      };

  String passwordChange;
}

class UploadTransactionFile {
  UploadTransactionFile();
  UploadTransactionFile.fromJson(Map<String, dynamic> json) : super();

  Map<String, dynamic> toJson() => <String, dynamic>{};

  // No supertype, so skipping location.
  // @override String get path => 'api/portfolio/import/upload';

}

class UploadTransactionFileResponse {
  UploadTransactionFileResponse(this.availableImportFormats, /* nullable */ this.customCsvParserConfig,
      /* nullable */ this.importFormat, this.importId);
  UploadTransactionFileResponse.fromJson(Map<String, dynamic> json)
      : availableImportFormats = (json['availableImportFormats'] as List<dynamic>)
            .map((dynamic val) => ImportTypeDto.fromJson(val as Map<String, dynamic>))
            .toList(),
        customCsvParserConfig = json['customCsvParserConfig'] == null
            ? null
            : CustomCsvParserConfig.fromJson(json['customCsvParserConfig'] as Map<String, dynamic>),
        importFormat = convertImportTypeFromJson(json['importFormat'] as String),
        importId = json['importId'] as String;

  Map<String, dynamic> toJson() => <String, dynamic>{
        'availableImportFormats': availableImportFormats.map<dynamic>((dynamic val) => val.toJson()).toList(),
        'customCsvParserConfig': customCsvParserConfig?.toJson(),
        'importFormat': convertImportTypeToJson(importFormat),
        'importId': importId,
      };

  List<ImportTypeDto> availableImportFormats;
  CustomCsvParserConfig customCsvParserConfig;
  ImportType importFormat;
  String importId;
}

class UrlDeserializedState {
  UrlDeserializedState(this.protocol, this.host, this.port, this.authority, this.file, this.ref);
  UrlDeserializedState.fromJson(Map<String, dynamic> json)
      : protocol = json['protocol'] as String,
        host = json['host'] as String,
        port = json['port'] as int,
        authority = json['authority'] as String,
        file = json['file'] as String,
        ref = json['ref'] as String;

  Map<String, dynamic> toJson() => <String, dynamic>{
        'protocol': protocol,
        'host': host,
        'port': port,
        'authority': authority,
        'file': file,
        'ref': ref,
      };

  String protocol;
  String host;
  int port;
  String authority;
  String file;
  String ref;
}

class UserAuthEmailToken {
  UserAuthEmailToken(this.createdAt, this.email, this.sentEmailAt, this.token, this.usedAt, this.user);
  UserAuthEmailToken.fromJson(Map<String, dynamic> json)
      : createdAt = InstantWrapper.fromJson(json['createdAt'] as int),
        email = json['email'] as String,
        sentEmailAt = InstantWrapper.fromJson(json['sentEmailAt'] as int),
        token = json['token'] as String,
        usedAt = InstantWrapper.fromJson(json['usedAt'] as int),
        user = UserInfo.fromJson(json['user'] as Map<String, dynamic>);

  Map<String, dynamic> toJson() => <String, dynamic>{
        'createdAt': createdAt.toJson(),
        'email': email,
        'sentEmailAt': sentEmailAt.toJson(),
        'token': token,
        'usedAt': usedAt.toJson(),
        'user': user.toJson(),
      };

  InstantWrapper createdAt;
  String email;
  InstantWrapper sentEmailAt;
  String token;
  InstantWrapper usedAt;
  UserInfo user;
}

class UserInfo {
  UserInfo(this.authTokens, this.createdAt, this.displayName, this.email, /* nullable */ this.firstName, this.id,
      /* nullable */ this.lastName, this.passwordHash, /* nullable */ this.phoneNumber, this.userType);
  UserInfo.fromJson(Map<String, dynamic> json)
      : authTokens = (json['authTokens'] as List<dynamic>)
            .map((dynamic val) => UserAuthEmailToken.fromJson(val as Map<String, dynamic>))
            .toList(),
        createdAt = InstantWrapper.fromJson(json['createdAt'] as int),
        displayName = json['displayName'] as String,
        email = json['email'] as String,
        firstName = json['firstName'] as String,
        id = json['id'] as String,
        lastName = json['lastName'] as String,
        passwordHash = json['passwordHash'] as String,
        phoneNumber = json['phoneNumber'] as String,
        userType = convertUserTypeFromJson(json['userType'] as String);

  Map<String, dynamic> toJson() => <String, dynamic>{
        'authTokens': authTokens.map<dynamic>((dynamic val) => val.toJson()).toList(),
        'createdAt': createdAt.toJson(),
        'displayName': displayName,
        'email': email,
        'firstName': firstName,
        'id': id,
        'lastName': lastName,
        'passwordHash': passwordHash,
        'phoneNumber': phoneNumber,
        'userType': convertUserTypeToJson(userType),
      };

  List<UserAuthEmailToken> authTokens;
  InstantWrapper createdAt;
  String displayName;
  String email;
  String firstName;
  String id;
  String lastName;
  String passwordHash;
  String phoneNumber;
  UserType userType;
}

class UserInfoAvatarUpload extends _Location with _LocationMixin implements PostBodyLocation<Unit, UserInfoResponse> {
  UserInfoAvatarUpload();
  UserInfoAvatarUpload.fromJson(Map<String, dynamic> json) : super();

  Map<String, dynamic> toJson() => <String, dynamic>{};

  @override
  String get path => 'api/game/userInfo/upload';

  @override
  UserInfoResponse bodyFromPostJson(dynamic json) => UserInfoResponse.fromJson(json as Map<String, dynamic>);
}

class UserInfoLocation extends _Location
    with _LocationMixin
    implements PostBodyLocation<UserInfoRequest, UserInfoResponse> {
  UserInfoLocation();
  UserInfoLocation.fromJson(Map<String, dynamic> json) : super();

  Map<String, dynamic> toJson() => <String, dynamic>{};

  @override
  String get path => 'api/game/userInfo';

  @override
  UserInfoResponse bodyFromPostJson(dynamic json) => UserInfoResponse.fromJson(json as Map<String, dynamic>);
}

class UserInfoRequest {
  UserInfoRequest(this.appVersion, this.deviceInfo, /* nullable */ this.fcmToken);
  UserInfoRequest.fromJson(Map<String, dynamic> json)
      : appVersion = json['appVersion'] as String,
        deviceInfo = json['deviceInfo'] as String,
        fcmToken = json['fcmToken'] as String;

  Map<String, dynamic> toJson() => <String, dynamic>{
        'appVersion': appVersion,
        'deviceInfo': deviceInfo,
        'fcmToken': fcmToken,
      };

  String appVersion;
  String deviceInfo;
  String fcmToken;
}

class UserInfoResponse {
  UserInfoResponse(this.avatarUrl, this.createdAt, this.displayName, this.email, this.key, this.statsCorrectAnswers,
      this.statsTotalTurns, this.userType);
  UserInfoResponse.fromJson(Map<String, dynamic> json)
      : avatarUrl = json['avatarUrl'] as String,
        createdAt = InstantWrapper.fromJson(json['createdAt'] as int),
        displayName = json['displayName'] as String,
        email = json['email'] as String,
        key = json['key'] as String,
        statsCorrectAnswers = json['statsCorrectAnswers'] as int,
        statsTotalTurns = json['statsTotalTurns'] as int,
        userType = convertGameUserTypeFromJson(json['userType'] as String);

  Map<String, dynamic> toJson() => <String, dynamic>{
        'avatarUrl': avatarUrl,
        'createdAt': createdAt.toJson(),
        'displayName': displayName,
        'email': email,
        'key': key,
        'statsCorrectAnswers': statsCorrectAnswers,
        'statsTotalTurns': statsTotalTurns,
        'userType': convertGameUserTypeToJson(userType),
      };

  String avatarUrl;
  InstantWrapper createdAt;
  String displayName;
  String email;
  String key;
  int statsCorrectAnswers;
  int statsTotalTurns;
  GameUserType userType;
}

class UserInfoUpdateLocation extends _Location
    with _LocationMixin
    implements PostBodyLocation<UserInfoUpdateRequest, UserInfoResponse> {
  UserInfoUpdateLocation();
  UserInfoUpdateLocation.fromJson(Map<String, dynamic> json) : super();

  Map<String, dynamic> toJson() => <String, dynamic>{};

  @override
  String get path => 'api/game/userInfo/update';

  @override
  UserInfoResponse bodyFromPostJson(dynamic json) => UserInfoResponse.fromJson(json as Map<String, dynamic>);
}

class UserInfoUpdateRequest {
  UserInfoUpdateRequest(this.displayName, this.email);
  UserInfoUpdateRequest.fromJson(Map<String, dynamic> json)
      : displayName = json['displayName'] as String,
        email = json['email'] as String;

  Map<String, dynamic> toJson() => <String, dynamic>{
        'displayName': displayName,
        'email': email,
      };

  String displayName;
  String email;
}

class VerifyToken extends _Location with _LocationMixin implements PostBodyLocation<VerifyTokenRequest, ContextDto> {
  VerifyToken();
  VerifyToken.fromJson(Map<String, dynamic> json) : super();

  Map<String, dynamic> toJson() => <String, dynamic>{};

  @override
  String get path => 'api/auth/verifyToken';

  @override
  ContextDto bodyFromPostJson(dynamic json) => ContextDto.fromJson(json as Map<String, dynamic>);
}

class VerifyTokenRequest {
  VerifyTokenRequest(this.emailToken);
  VerifyTokenRequest.fromJson(Map<String, dynamic> json) : emailToken = json['emailToken'] as String;

  Map<String, dynamic> toJson() => <String, dynamic>{
        'emailToken': emailToken,
      };

  String emailToken;
}

class WDCompanyInfoDto {
  WDCompanyInfoDto(
      this.companyDescription,
      this.companyLabel,
      /* nullable */ this.industry,
      /* nullable */ this.industryLabel,
      this.logo,
      /* nullable */ this.tickerSymbol,
      this.website,
      /* nullable */ this.wikidataEntityUri,
      /* nullable */ this.wikipediaArticleUri);
  WDCompanyInfoDto.fromJson(Map<String, dynamic> json)
      : companyDescription = json['companyDescription'] as String,
        companyLabel = json['companyLabel'] as String,
        industry = json['industry'] == null ? null : URI.fromJson(json['industry'] as Map<String, dynamic>),
        industryLabel = json['industryLabel'] as String,
        logo = URL.fromJson(json['logo'] as Map<String, dynamic>),
        tickerSymbol = json['tickerSymbol'] as String,
        website = URL.fromJson(json['website'] as Map<String, dynamic>),
        wikidataEntityUri = json['wikidataEntityUri'] as String,
        wikipediaArticleUri = json['wikipediaArticleUri'] as String;

  Map<String, dynamic> toJson() => <String, dynamic>{
        'companyDescription': companyDescription,
        'companyLabel': companyLabel,
        'industry': industry?.toJson(),
        'industryLabel': industryLabel,
        'logo': logo.toJson(),
        'tickerSymbol': tickerSymbol,
        'website': website.toJson(),
        'wikidataEntityUri': wikidataEntityUri,
        'wikipediaArticleUri': wikipediaArticleUri,
      };

  String companyDescription;
  String companyLabel;
  URI industry;
  String industryLabel;
  URL logo;
  String tickerSymbol;
  URL website;
  String wikidataEntityUri;
  String wikipediaArticleUri;
}

class YearMoverShares {
  YearMoverShares(
      /* nullable */ this.companyLabel,
      /* nullable */ this.companyWebsite,
      this.instrumentId,
      this.instrumentSymbol,
      this.marketCap,
      this.volume,
      this.weekMoveDay,
      this.weekMoveValue,
      this.yearMoveDay,
      this.yearMoveValue);
  YearMoverShares.fromJson(Map<String, dynamic> json)
      : companyLabel = json['companyLabel'] as String,
        companyWebsite = json['companyWebsite'] as String,
        instrumentId = json['instrumentId'] as String,
        instrumentSymbol = json['instrumentSymbol'] as String,
        marketCap = (json['marketCap'] as num).toDouble(),
        volume = (json['volume'] as num).toDouble(),
        weekMoveDay = json['weekMoveDay'] as /* yyyy-mm-dd date LocalDate */ String,
        weekMoveValue = (json['weekMoveValue'] as num).toDouble(),
        yearMoveDay = json['yearMoveDay'] as /* yyyy-mm-dd date LocalDate */ String,
        yearMoveValue = (json['yearMoveValue'] as num).toDouble();

  Map<String, dynamic> toJson() => <String, dynamic>{
        'companyLabel': companyLabel,
        'companyWebsite': companyWebsite,
        'instrumentId': instrumentId,
        'instrumentSymbol': instrumentSymbol,
        'marketCap': marketCap,
        'volume': volume,
        'weekMoveDay': weekMoveDay,
        'weekMoveValue': weekMoveValue,
        'yearMoveDay': yearMoveDay,
        'yearMoveValue': yearMoveValue,
      };

  String companyLabel;
  String companyWebsite;
  String instrumentId;
  String instrumentSymbol;
  double marketCap;
  double volume;
  /* yyyy-mm-dd date LocalDate */ String weekMoveDay;
  double weekMoveValue;
  /* yyyy-mm-dd date LocalDate */ String yearMoveDay;
  double yearMoveValue;
}
